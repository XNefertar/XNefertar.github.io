<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="The Redefine Team">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://xnefertar.github.io/2024/12/05/linux高级io模型/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高级IO模型">
<meta property="og:url" content="http://xnefertar.github.io/2024/12/05/Linux%E9%AB%98%E7%BA%A7IO%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xnefertar.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2024-12-05T05:26:00.000Z">
<meta property="article:modified_time" content="2025-05-19T16:55:10.734Z">
<meta property="article:author" content="XNefertar">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xnefertar.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            Linux高级IO模型 | XNefertar&#39;s Blog
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"xnefertar.github.io","root":"/","language":"zh-CN"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"atom-one-light","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Hello World!","subtitle":{"text":["Like a poem, so should be a program."],"hitokoto":{"enable":false,"show_author":true,"api":"https://v1.hitokoto.cn"},"typing_speed":80,"backing_speed":50,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"github":{"icon":"fa-solid fa-link","path":"/links/"},"Tags":{"icon":"fa-solid fa-tags","path":"/tags/"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/X.png" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                XNefertar&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links/"
                                        >
                                    <i class="fa-solid fa-link fa-fw"></i>
                                    GITHUB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links/"
                        >
                            <span>
                                GITHUB
                            </span>
                            
                                <i class="fa-solid fa-link fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">12</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Linux高级IO模型</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">The Redefine Team</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-12-05 13:26</span>
        <span class="mobile">2024-12-05 13:26</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-05-20 00:55:10</span>
            <span class="mobile">2025-05-20 00:55:10</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Linux/">Linux</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>13.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>58 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="Linux-网络高级-IO"><a href="#Linux-网络高级-IO" class="headerlink" title="Linux 网络高级 IO"></a>Linux 网络高级 IO</h1><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><blockquote>
<p>本文将介绍Linux网络编程中的五种常见网络高级IO函数</p>
<ol>
<li>阻塞IO<ol>
<li>在内核将数据准备好之前, 系统调用会一直等待. </li>
<li>所有的套接字, 默认都是阻塞方式.</li>
</ol>
</li>
<li>非阻塞IO<ol>
<li>如果内核还未将数据准备好, 系统调用仍然会直接返回</li>
<li>返回EWOULDBLOCK错误码.</li>
<li>该IO模式常需要以循环的方式反复尝试读写文件描述符, 这个过程称为<code>轮询</code></li>
<li>但是<code>轮询</code>会带来大量的CPU资源浪费，所以该IO模式一般只在特定场景下应用</li>
</ol>
</li>
<li>信号驱动IO<ol>
<li>内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作</li>
</ol>
</li>
<li>IO多路转接<ol>
<li>类似于阻塞IO,</li>
<li>最核心在于IO多路转接能够同时等待多个文件 描述符的就绪状态</li>
</ol>
</li>
<li>异步IO<ol>
<li>在数据拷贝完成时, 内核会通知应用程序</li>
<li>信号驱动则是告诉应用程序何时可以开始拷贝数据</li>
</ol>
</li>
</ol>
<p>总结：</p>
<p>所有的IO均可看作<code>等待</code> + <code>拷贝</code>，其中<code>等待</code>的时间常常远高于<code>拷贝</code>，所以高效的IO模式都是尽量减少等待的时间（后面会具体介绍）;</p>
</blockquote>
<h2 id="高级IO重要概念"><a href="#高级IO重要概念" class="headerlink" title="高级IO重要概念"></a>高级IO重要概念</h2><h3 id="同步通信-synchronous-communication-VS-异步通信-asynchronous-communication"><a href="#同步通信-synchronous-communication-VS-异步通信-asynchronous-communication" class="headerlink" title="同步通信 (synchronous communication) VS 异步通信 (asynchronous communication)"></a>同步通信 (synchronous communication) VS 异步通信 (asynchronous communication)</h3><p>同步和异步关注的是消息通信机制：</p>
<blockquote>
<ul>
<li>同步</li>
</ul>
<p>直接由调用者进行等待，在处理完成之前，调用者会一直等待该处理结果的返回，期间调用者不会进行其他的操作；</p>
<ul>
<li>异步</li>
</ul>
<p>调用者不会一直进行阻塞式等待，当处理完成后，被调用者会通过一系列的机制（回调函数、信号等）通知调用者，调用者收到对应的完成信号后执行后续操作；</p>
</blockquote>
<p>然而，需要注意与多进程&#x2F;多线程同步&#x2F;互斥的区别，两者毫不相关：</p>
<blockquote>
<ul>
<li><p>进程&#x2F;线程同步也是进程&#x2F;线程之间直接的制约关系</p>
</li>
<li><p>是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、 传递信息所产生的制约关系. 尤其是在访问临界资源的时候</p>
</li>
</ul>
</blockquote>
<h3 id="阻塞-VS-非阻塞"><a href="#阻塞-VS-非阻塞" class="headerlink" title="阻塞 VS 非阻塞"></a>阻塞 VS 非阻塞</h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</p>
<blockquote>
<ul>
<li>阻塞调用是指调用结果返回之前，对应的线程会被挂起，直到收到响应信号时才会返回；</li>
<li>非阻塞则不同于阻塞，即使未收到响应信号，线程也不会被挂起，而是继续执行接下来的操作；</li>
</ul>
</blockquote>
<h3 id="其他高级IO"><a href="#其他高级IO" class="headerlink" title="其他高级IO"></a>其他高级IO</h3><p>非阻塞IO，纪录锁，系统V流机制，I&#x2F;O多路转接（也叫I&#x2F;O多路复用）,readv和writev函数以及存储映射 IO（mmap），这些统称为高级IO<br>本文重点讨论 I&#x2F;O 多路转接；</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><p>文件描述符控制函数，默认是阻塞 IO</p>
<p><strong>函数原型</strong></p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数说明</strong></p>
<p><em>cmd</em></p>
<blockquote>
<p>F_DUPFD：								复制一个现有的描述符</p>
<p>F_GETFD &#x2F; F_SETFD： 					  获得&#x2F;设置文件描述符标记</p>
<p>F_GETFL &#x2F; F_SETFL： 					   获得&#x2F;设置文件状态标记</p>
<p>F_GETOWN &#x2F; F_SETOWN：			   	获得&#x2F;设置异步I&#x2F;O所有权</p>
<p>F_GETLK &#x2F; F_SETLK &#x2F; F_SETLKW： 		    获得&#x2F;设置记录锁</p>
</blockquote>
<p><strong>用法实例</strong></p>
<p>——以设置文件描述符为非阻塞模式为例</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetNoBlock</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前文件描述符模式</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;ERROR FD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flag | O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>细节</em></p>
<p>这里获取的<code>flag</code>，请注意它是一个位图结构，关于位图结构，可以粗略的将它看作是一个_比特位容器_，每个位置上的0&#x2F;1值都代表着不同的含义，当然位图的实现依据不同的功能有不同的实现方案，肯定不会只是一个简单的<code>int</code>类型可表示的，这里只是用作理解；</p>
<p><strong>以轮询方式读取标准输入</strong></p>
<p>在我们完成了上述的非阻塞模式设置函数后，我们就可以基于此实现<code>以轮询方式读取标准输入</code>的功能：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetNoBlock</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前文件描述符模式</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;ERROR FD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flag | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 标准输入的文件描述符默认是0</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 标准输出</span></span><br><span class="line">    <span class="comment">// 2 -&gt; 标准错误</span></span><br><span class="line">    <span class="built_in">SetNoBlock</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 死循环模拟轮询状态</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="comment">// 以非阻塞方式</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(<span class="number">0</span>, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR READ&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GetInput # &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I&#x2F;O多路转接"></a>I&#x2F;O多路转接</h1><p>什么是多路转接：通俗的理解就是多个信号或数据流共享一条通信管道，通过各种机制（如信号）实现数据的有序传递，下面分别介绍几种常见的通信机制：</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><h3 id="初识select"><a href="#初识select" class="headerlink" title="初识select"></a>初识select</h3><p>系统提供select函数来实现多路复用输入&#x2F;输出模型</p>
<blockquote>
<ul>
<li><p>select系统调用是用来让我们的程序监视多个文件描述符的状态变化的；</p>
</li>
<li><p>程序会停在select这里等待，直到被监视的文件描述符有一个或多个发生了状态改变</p>
</li>
</ul>
</blockquote>
<h3 id="select-函数原型"><a href="#select-函数原型" class="headerlink" title="select 函数原型"></a>select 函数原型</h3><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function"> 		  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数解释</strong></p>
<blockquote>
<ul>
<li>nfds：最大的可用文件描述符 + 1；</li>
<li>readfds：监听读事件的文件描述符的集合，这里的 fd_set 即表示一个文件描述符集合；</li>
<li>writefds：同上，表示被监听的写事件的文件描述符集合；</li>
<li>exceptfds：同上，表示被监听的异常事件的文件描述符集合；</li>
<li>timeout：用来设置 select 的超时时间（用来区分非阻塞和阻塞模式）</li>
</ul>
</blockquote>
<p><strong>timeout 取值</strong></p>
<blockquote>
<ul>
<li>NULL：则表示 select 没有timeout，select将一直被阻塞，直到某个文件描述符上发生了事件； ——阻塞等待</li>
<li>0：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生； ——非阻塞等待</li>
<li>特定的时间值：如果在指定的时间段里没有事件发生，select将超时返回； ——超时时间内阻塞，超时时间外非阻塞</li>
</ul>
</blockquote>
<p><strong>fd_set</strong></p>
<p>位图结构，对应的位标识所监视的文件描述符；</p>
<blockquote>
<p>操作函数（位图结构不是简单类型，不可以通过位运算进行直接操作）</p>
<ul>
<li>void FD_CLR(int fd, fd_set *set);  &#x2F;&#x2F; 用来清除描述词组set中相关fd 的位 </li>
<li>int FD_ISSET(int fd, fd_set *set);  &#x2F;&#x2F; 用来测试描述词组set中相关fd的位是否为真 </li>
<li>void FD_SET(int fd, fd_set *set);  &#x2F;&#x2F; 用来设置描述词组set中相关fd的位 </li>
<li>void FD_ZERO(fd_set *set);         &#x2F;&#x2F; 用来清除描述词组set的全部位</li>
</ul>
</blockquote>
<p><strong>返回值</strong></p>
<blockquote>
<ul>
<li>执行成功则返回文件描述词状态已改变的个数 </li>
<li>如果返回0代表在描述词状态改变前已超过timeout时间，没有返回</li>
<li>当有错误发生时则返回-1，错误原因存于errno，此时参数 readfds, writefds, exceptfds 和 timeout 的值变成不可预测；</li>
</ul>
</blockquote>
<p><em>常见错误值</em></p>
<blockquote>
<ul>
<li>EBADF 文件描述词为无效的或该文件已关闭</li>
<li>EINTR 此调用被信号所中断</li>
<li>EINVAL 参数 n 为负值</li>
<li>ENOMEM 核心内存不足</li>
</ul>
</blockquote>
<h3 id="select-函数执行过程"><a href="#select-函数执行过程" class="headerlink" title="select 函数执行过程"></a>select 函数执行过程</h3><p>理解select函数执行过程，需要与其操作函数相结合，这里以一个字节（8位）位图为例：</p>
<blockquote>
<ol>
<li>首先重置位图结构——<code>FD_ZERO</code>，位图变为 (0000 0000)；</li>
<li>再设置需要监听的文件描述符，这里以 fd &#x3D; 4为例——<code>FD_SET(4, &amp;fd_set);</code>(0001 0000)</li>
<li>当监听到对应的文件描述符上由事件就绪时（事件类型由对应的文件描述符集合确定，这里是阻塞等待），<strong>fd_set被重新设置</strong>，对应位上的值被置为1，而监听的文件描述符若未就绪，则会被置为0；(0001 0000)</li>
<li>接收端读取select返回的信号，检索fd_set，执行相应操作；</li>
</ol>
</blockquote>
<h3 id="select-就绪条件"><a href="#select-就绪条件" class="headerlink" title="select 就绪条件"></a>select 就绪条件</h3><h4 id="读就绪"><a href="#读就绪" class="headerlink" title="读就绪"></a>读就绪</h4><ul>
<li><p><strong>套接字 (Sockets)</strong></p>
<ul>
<li><p><strong>监听套接字 (Listening Socket, e.g., created by socket, bind, listen)</strong> 如果有新的连接请求已完成（pending connection），accept() 将不会阻塞。</p>
</li>
<li><p><strong>已连接的流套接字 (Connected Stream Socket, e.g., TCP)</strong></p>
<ul>
<li><p>套接字接收缓冲区中的数据字节数大于等于套接字<strong>接收缓冲区低水位标记（SO_RCVLOWAT，默认为1）</strong>。这意味着调用 read() 或 recv() 将不会阻塞，并且会返回大于 0 的值（读取到的数据）。</p>
<blockquote>
<h4 id="低水平标记"><a href="#低水平标记" class="headerlink" title="低水平标记"></a>低水平标记</h4><ol>
<li><strong>接收低水位标记 (Receive Low Water Mark, SO_RCVLOWAT)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>: 当套接字接收缓冲区中<strong>累积的数据字节数达到或超过</strong>这个标记值时，select&#x2F;poll&#x2F;epoll 才会通知应用程序该套接字“可读”。</li>
<li><strong>默认值</strong>: 通常为1字节。</li>
</ul>
<ol start="2">
<li><strong>发送低水位标记 (Send Low Water Mark, SO_SNDLOWAT)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>: 当套接字发送缓冲区中的<strong>可用空间字节数达到或超过</strong>这个标记值时，select&#x2F;poll&#x2F;epoll 才会通知应用程序该套接字“可写”。</li>
<li><strong>默认值</strong>: 通常也比较小，例如允许写入至少一个字节。</li>
</ul>
<h4 id="为什么需要低水位标记？它的作用是什么？"><a href="#为什么需要低水位标记？它的作用是什么？" class="headerlink" title="为什么需要低水位标记？它的作用是什么？"></a>为什么需要低水位标记？它的作用是什么？</h4><ol>
<li><strong>减少不必要的唤醒和系统调用 (针对SO_RCVLOWAT)</strong>:<ul>
<li><strong>场景</strong>: 想象一个应用，如果每当接收缓冲区有一个字节到达时就被唤醒，它就需要执行一次 read() 系统调用。如果数据是零散到达的（比如，对端一次只发送几个字节），那么应用程序会被频繁唤醒，每次唤醒只处理少量数据。这会导致大量的上下文切换和系统调用开销，效率低下。</li>
<li><strong>作用</strong>: 通过设置一个较高的 SO_RCVLOWAT（例如，设置为1024字节），应用程序只有在接收缓冲区中累积了足够多的数据（至少1024字节）时才会被通知。这样，一次 read() 调用可以读取更多的数据，减少了唤醒次数和系统调用次数，提高了整体吞吐量和效率。</li>
<li><strong>权衡</strong>: 设置过高的 SO_RCVLOWAT 可能会增加延迟，因为应用程序需要等待更多数据到达才会被唤醒。</li>
</ul>
</li>
<li><strong>控制写入的粒度 (针对SO_SNDLOWAT)</strong>:<ul>
<li><strong>场景</strong>: 类似地，如果发送缓冲区只有少量空间可用时就通知应用程序可写，应用程序可能会尝试写入少量数据，导致频繁的 write() 调用和可能的<strong>网络小包问题</strong>（Nagle算法可能会缓解，但不是所有情况）。</li>
<li><strong>作用</strong>: 通过设置一个合适的 SO_SNDLOWAT，可以确保在发送缓冲区有足够空间容纳一个有意义的数据块时才通知应用程序可写。这有助于应用程序进行更有效率的批量写入。</li>
<li><strong>权衡</strong>: 对于某些需要低延迟的应用，即使只有少量空间也希望尽快发送数据，此时较小的 SO_SNDLOWAT（甚至默认值）可能更合适。</li>
</ul>
</li>
<li><strong>避免“忙等”或过于频繁的轮询</strong>:<ul>
<li>如果没有低水位标记（或者说标记总是1），在数据流速较慢或不稳定的情况下，select&#x2F;poll&#x2F;epoll 可能会在只有极少量数据可操作时就返回。如果应用程序逻辑是“只要可读&#x2F;可写就一直读&#x2F;写”，可能会导致非常频繁地进入和退出内核态，即使每次操作的数据量很小。</li>
<li>低水位标记提供了一种机制，让内核在条件“更有意义”时才通知用户。</li>
</ul>
</li>
<li><strong>配合应用层协议</strong>:<ul>
<li>某些应用层协议有最小消息大小或期望一次处理的数据块大小。通过设置合适的低水位标记，可以使得内核通知的时机与应用层的数据处理逻辑更匹配。例如，如果应用总是期望处理至少一个完整的协议单元，可以将 SO_RCVLOWAT 设置为该协议单元的典型大小。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>连接的读取半部已经关闭（例如，对端发送了 FIN）。此时调用 read() 或 recv() 将不会阻塞，而是返回 0（表示 EOF）。</p>
</li>
<li><p>套接字上发生了错误（error pending）。此时调用 read() 或 recv() 将不会阻塞，而是返回 -1 并设置 errno 为相应的错误码（例如 ECONNRESET）。这些错误也可以通过 getsockopt(SO_ERROR) 来获取。</p>
</li>
</ul>
</li>
<li><p><strong>数据报套接字 (Datagram Socket, e.g., UDP)</strong> 有一个待处理的数据报可供读取。recvfrom() 将不会阻塞。</p>
</li>
</ul>
</li>
<li><p><strong>管道 (Pipes) 或 FIFO</strong></p>
<ul>
<li>管道中有数据可读。read() 将不会阻塞。</li>
<li>管道的写端已经关闭。read() 将不会阻塞，而是返回 0 (EOF)。</li>
</ul>
</li>
<li><p><strong>终端设备 (Terminals)</strong> 有未读的数据。</p>
</li>
<li><p><strong>常规文件 (Regular Files)</strong> 通常总是被认为是可读的（除非指针在文件末尾）。但 select 主要用于网络和管道这类可能阻塞的 I&#x2F;O。</p>
</li>
</ul>
<h4 id="写就绪"><a href="#写就绪" class="headerlink" title="写就绪"></a>写就绪</h4><p>一个文件描述符被认为是可写的，如果以下任一条件成立：</p>
<ul>
<li><strong>套接字 (Sockets):</strong><ul>
<li><strong>已连接的流套接字 (Connected Stream Socket, e.g., TCP):</strong><ul>
<li>套接字发送缓冲区中的<strong>可用空间大于等于套接字发送缓冲区低水位标记（SO_SNDLOWAT，默认为1）</strong>，并且套接字已连接（或者不需要连接，如 UDP）。这意味着调用 write() 或 send() 通常不会阻塞（或者阻塞时间会很短，不会超过发送超时）。</li>
<li>连接的写入半部已经关闭。此时调用 write() 或 send() 通常会产生 SIGPIPE 信号，或者返回 -1 并设置 errno 为 EPIPE。<em>注意：即使写入会失败，select 也可能报告其可写，所以需要处理写入错误。</em></li>
<li>一个非阻塞的 connect() 调用已经成功完成。</li>
<li>套接字上发生了错误（error pending）。此时调用 write() 或 send() 将不会阻塞，而是返回 -1 并设置 errno。这些错误也可以通过 <code>getsockopt(SO_ERROR)</code>来获取。</li>
</ul>
</li>
<li><strong>数据报套接字 (Datagram Socket, e.g., UDP):</strong> 通常总是可写的，因为 UDP 是无连接的，发送操作通常不会阻塞，除非内核缓冲区暂时满了。</li>
</ul>
</li>
<li><strong>管道 (Pipes) 或 FIFO:</strong><ul>
<li>管道中有足够的空间可供写入数据（至少一个字节）。write() 将不会阻塞。</li>
<li>管道的读端已经关闭。write() 将会产生 SIGPIPE 信号，或者返回 -1 并设置 errno 为 EPIPE。</li>
</ul>
</li>
<li><strong>终端设备 (Terminals):</strong> 可以写入。</li>
<li><strong>常规文件 (Regular Files):</strong> 通常总是被认为是可写的（除非磁盘空间已满或超出配额）。</li>
</ul>
<p><strong>异常就绪</strong></p>
<p>一个文件描述符被认为有异常条件，如果：</p>
<ul>
<li><strong>套接字 (Sockets):</strong><ul>
<li>接收到带外数据 (Out-Of-Band, OOB data)，仅适用于支持 OOB 数据的协议（如 TCP）。</li>
<li>在某些情况下，当套接字上存在待处理的错误时，也可能在 exceptfds 中报告。但更常见的是通过可读或可写条件来发现错误（即读写操作返回-1）。</li>
</ul>
</li>
<li><strong>伪终端 (Pseudo-terminals):</strong> 在包模式 (packet mode) 下，当主控端检测到从属端的状态改变时。</li>
</ul>
<h3 id="select-的特点"><a href="#select-的特点" class="headerlink" title="select 的特点"></a>select 的特点</h3><ul>
<li><p>可监控的文件描述符取决于<code>sizeof(fd_set)</code>的大小，以我自己的系统为例，<code>sizeof(fd_set)</code>大小为128 bytes，而每一位都可以标识一个文件描述符，所以可监控的文件描述符为<code>128 * 8 = 1024</code>；</p>
<blockquote>
<p>fd_set 的大小可以调整，具体方法可能涉及重新编译内核；</p>
</blockquote>
</li>
<li><p>将 fd 加入监控集的同时，还要再使用一个数据结构 array 保存到 select 监控集合中的 fd</p>
<ul>
<li>一是用于再select 返回后，array作为源数据和fd_set进行FD_ISSET判断；</li>
<li>二是select返回后会把以前加入的但并无事件发生的fd清空，则每次开始select前都要重新从array取得 fd 逐一加入(FD_ZERO最先)，扫描array的同时取得fd最大值maxfd，用于select的第一个参数；</li>
</ul>
</li>
</ul>
<h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ul>
<li><strong>每次调用select, 都需要手动设置fd集合</strong>, 从接口使用角度来说也非常不便；</li>
<li>每次调用select，都需要把fd集合<strong>从用户态拷贝到内核态</strong>，这个开销在fd很多时会很大；<blockquote>
<p>用户无法对内核数据进行直接操作，所有的操作都是操作系统通过对应的文件描述符对对应的资源进行操作；</p>
</blockquote>
</li>
<li>每次调用select都<strong>需要在内核遍历传递进来的所有fd</strong>，这个开销在fd很多时也很大；</li>
<li>select<strong>支持的文件描述符数量太小</strong>；</li>
</ul>
<h3 id="select-的使用实例"><a href="#select-的使用实例" class="headerlink" title="select 的使用实例"></a>select 的使用实例</h3><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// for close, read, write, STDIN_FILENO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>     <span class="comment">// for memset, strerror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>     <span class="comment">// for exit, EXIT_FAILURE, EXIT_SUCCESS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>      <span class="comment">// 用于存储客户端套接字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>   <span class="comment">// for std::max</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">1024</span>; <span class="comment">// 缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEFAULT_PORT = <span class="number">8889</span>; <span class="comment">// 默认端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _listenFd;         <span class="comment">// 监听套接字</span></span><br><span class="line">    fd_set _masterFds;     <span class="comment">// 主文件描述符集合, 保存所有需要监视的fd</span></span><br><span class="line">    fd_set _readFds;       <span class="comment">// 临时的文件描述符集合, 用于select调用</span></span><br><span class="line">    <span class="type">int</span> _maxFd;            <span class="comment">// 当前监视的最大文件描述符值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 套接字辅助函数 ---</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;socket 创建失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Socket fd 创建成功: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 设置端口复用, 以便服务器快速重启</span></span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;setsockopt(SO_REUSEADDR) 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 这里不退出, 但记录错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);         <span class="comment">// 将主机字节序转换为网络字节序 (Port)</span></span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 监听任意网络接口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;bind 错误, 端口 &quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bind 成功, fd: &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 到端口 &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog = <span class="number">5</span>)</span> <span class="comment">// backlog 是等待连接队列的最大长度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(fd, backlog) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;listen 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listen 成功, fd: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> sock, std::string&amp; clientIp, <span class="type">uint16_t</span>&amp; clientPort)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">        <span class="type">int</span> clientFd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对于阻塞的accept, 这里通常是真正的错误</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123; <span class="comment">// 如果是非阻塞模式, EAGAIN/EWOULDBLOCK表示没有连接</span></span><br><span class="line">                 std::cerr &lt;&lt; <span class="string">&quot;accept 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示错误或没有连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        clientIp = <span class="built_in">inet_ntoa</span>(client_addr.sin_addr); <span class="comment">// 将网络字节序的IP转换为点分十进制字符串</span></span><br><span class="line">        clientPort = <span class="built_in">ntohs</span>(client_addr.sin_port);   <span class="comment">// 将网络字节序的端口转换为主机字节序</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;接受新连接。客户端 fd: &quot;</span> &lt;&lt; clientFd</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; 来自 &quot;</span> &lt;&lt; clientIp &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; clientPort &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> clientFd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Select 特定辅助函数 ---</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddClientFdToMasterSet</span><span class="params">(<span class="type">int</span> clientFd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FD_SET</span>(clientFd, &amp;_masterFds); <span class="comment">// 将新的客户端fd添加到主集合中</span></span><br><span class="line">        <span class="keyword">if</span> (clientFd &gt; _maxFd) &#123;</span><br><span class="line">            _maxFd = clientFd; <span class="comment">// 更新最大文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端 fd &quot;</span> &lt;&lt; clientFd &lt;&lt; <span class="string">&quot; 已添加到 select 监视集合。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveClientFdFromMasterSet</span><span class="params">(<span class="type">int</span> clientFd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端 fd &quot;</span> &lt;&lt; clientFd &lt;&lt; <span class="string">&quot; 断开连接或出错, 正在关闭并从监视集合中移除。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientFd);</span><br><span class="line">        <span class="built_in">FD_CLR</span>(clientFd, &amp;_masterFds); <span class="comment">// 从主集合中移除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果移除的是最大的fd, 需要重新计算_maxFd</span></span><br><span class="line">        <span class="comment">// (一个简单的做法是遍历, 但对于频繁移除可能效率不高。</span></span><br><span class="line">        <span class="comment">//  在这个演示中, 为了简单, 我们可以在下次有新连接时更新, 或者保持它不变直到下一个更高的fd加入。</span></span><br><span class="line">        <span class="comment">//  更健壮的做法是遍历_masterFds找到新的最大值)</span></span><br><span class="line">        <span class="keyword">if</span> (clientFd == _maxFd) &#123;</span><br><span class="line">            <span class="comment">// 简单的重新计算 _maxFd (效率不高, 但对于演示足够)</span></span><br><span class="line">            _maxFd = _listenFd; <span class="comment">// 先设为监听fd</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= clientFd; ++i) &#123; <span class="comment">// 之前_maxFd是clientFd, 现在要找小于它的</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;_masterFds) &amp;&amp; i &gt; _maxFd) &#123;</span><br><span class="line">                    _maxFd = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 或者, 可以更懒惰一点, 在下一个add时自然更新, 只要保证select的第一个参数够大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleNewConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::string clientIp;</span><br><span class="line">        <span class="type">uint16_t</span> clientPort;</span><br><span class="line">        <span class="type">int</span> clientFd = <span class="built_in">Accept</span>(_listenFd, clientIp, clientPort);</span><br><span class="line">        <span class="keyword">if</span> (clientFd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">AddClientFdToMasterSet</span>(clientFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleClientData</span><span class="params">(<span class="type">int</span> clientFd)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> bytes_read = <span class="built_in">recv</span>(clientFd, buffer, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;从 fd &quot;</span> &lt;&lt; clientFd &lt;&lt; <span class="string">&quot; 收到: &quot;</span> &lt;&lt; buffer;</span><br><span class="line">            <span class="comment">// 简单的回显服务器: 将数据发回给客户端</span></span><br><span class="line">            <span class="built_in">send</span>(clientFd, buffer, bytes_read, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 客户端关闭了连接</span></span><br><span class="line">            <span class="built_in">RemoveClientFdFromMasterSet</span>(clientFd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// recv 发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123; <span class="comment">// EAGAIN 针对非阻塞套接字</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;fd &quot;</span> &lt;&lt; clientFd &lt;&lt; <span class="string">&quot; 上的 recv 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">RemoveClientFdFromMasterSet</span>(clientFd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SelectServer</span>(<span class="type">int</span> port) : _listenFd(<span class="number">-1</span>), _maxFd(<span class="number">-1</span>) &#123;</span><br><span class="line">        _listenFd = <span class="built_in">Socket</span>();</span><br><span class="line">        <span class="built_in">Bind</span>(_listenFd, port);</span><br><span class="line">        <span class="built_in">Listen</span>(_listenFd);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;_masterFds); <span class="comment">// 清空主文件描述符集合</span></span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;_readFds);   <span class="comment">// 清空临时读文件描述符集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将监听套接字添加到主集合中</span></span><br><span class="line">        <span class="built_in">FD_SET</span>(_listenFd, &amp;_masterFds);</span><br><span class="line">        _maxFd = _listenFd; <span class="comment">// 初始化最大文件描述符</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SelectServer 初始化完成。正在监听 fd &quot;</span> &lt;&lt; _listenFd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SelectServer</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_listenFd != <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;关闭监听 fd: &quot;</span> &lt;&lt; _listenFd &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(_listenFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭所有仍然在_masterFds中的客户端连接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= _maxFd; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;_masterFds) &amp;&amp; i != _listenFd) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;关闭客户端 fd: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">close</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SelectServer 关闭。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;服务器启动 select 循环...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            _readFds = _masterFds; <span class="comment">// 每次循环前, 从主集合复制到临时集合, 因为select会修改它</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// select的第一个参数是 nfds, 它应该是当前监视的最大文件描述符值 + 1</span></span><br><span class="line">            <span class="comment">// timeout 参数设为 NULL 表示永久阻塞直到有事件发生</span></span><br><span class="line">            <span class="type">int</span> nready = <span class="built_in">select</span>(_maxFd + <span class="number">1</span>, &amp;_readFds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINTR) <span class="keyword">continue</span>; <span class="comment">// 被信号中断, 重新select</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;select 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 严重错误, 退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nready == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果设置了超时且超时发生, 会到这里。</span></span><br><span class="line">                <span class="comment">// 但由于我们超时设为NULL, 理论上不应该到这里, 除非select行为异常。</span></span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; &quot;Select 超时。&quot; &lt;&lt; std::endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查哪些文件描述符就绪了</span></span><br><span class="line">            <span class="comment">// 首先检查监听套接字是否有新连接</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_listenFd, &amp;_readFds)) &#123;</span><br><span class="line">                <span class="built_in">HandleNewConnection</span>();</span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 优化: 如果所有就绪事件都已处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后检查所有客户端套接字是否有数据可读</span></span><br><span class="line">            <span class="comment">// 依次遍历事件监听位图</span></span><br><span class="line">            <span class="comment">// 较大的事件复杂度</span></span><br><span class="line">            <span class="comment">// 注意: 从0开始遍历到_maxFd, 但要跳过_listenFd, 因为它已经处理过了</span></span><br><span class="line">            <span class="comment">// 或者, 可以维护一个客户端fd列表, 只遍历那个列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= _maxFd; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;_readFds)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == _listenFd) &#123;</span><br><span class="line">                        <span class="comment">// 监听套接字已经处理过了, 跳过</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 是一个客户端套接字有数据</span></span><br><span class="line">                        <span class="built_in">HandleClientData</span>(i);</span><br><span class="line">                        <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 优化: 如果所有就绪事件都已处理</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> port = DEFAULT_PORT;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;无效的端口号: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">            port = DEFAULT_PORT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SelectServer <span class="title">server</span><span class="params">(port)</span></span>;</span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>该程序只检测标准输入（对应的文件描述符为0），当一直不输入时，就会产生超时信息；</p>
</blockquote>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>鉴于<code>select</code>带来的较大的拷贝开销和遍历成本，又提出了一种新的多路转接方式——<strong>poll</strong>；</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd; 	   <span class="comment">/* file descriptor */</span></span><br><span class="line">	<span class="type">short</span> events;  <span class="comment">/* requested events */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><p>fds：指向<code>pollfd</code>结构体的指针</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd; 	   <span class="comment">// 当前结构体所监视的文件描述符</span></span><br><span class="line">	<span class="type">short</span> events;  <span class="comment">// 当前文件描述符锁关心的时间，具体类型有:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		POLLIN：表示文件描述符可以进行读取操作（即有数据可读）。</span></span><br><span class="line"><span class="comment">		POLLOUT：表示文件描述符可以进行写入操作（即可以写数据）。</span></span><br><span class="line"><span class="comment">		POLLERR：表示文件描述符发生错误。</span></span><br><span class="line"><span class="comment">		POLLHUP：表示文件描述符被挂起，通常是连接关闭。</span></span><br><span class="line"><span class="comment">		POLLNVAL：表示文件描述符无效。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">// 返回的事件类型，poll 返回时会修改这个字段，告知哪些事件已经发生</span></span><br><span class="line">    			  <span class="comment">// 返回值是 events 字段中感兴趣的事件，或者是一些错误事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>nfds</strong>：表示当前所监视的文件描述符个数，即结构体指针指向的结构体个数</p>
</li>
<li><p><strong>timout</strong>：这是 <code>poll</code> 等待事件发生的最大时间，单位是毫秒，<code>timeout</code> 的值可以是以下几种：</p>
<ul>
<li><strong>大于 0</strong>：表示等待事件发生的最长时间（毫秒）。<code>poll</code> 会在超时之前返回，或者在事件发生时返回。</li>
<li><strong>0</strong>：表示非阻塞模式，<code>poll</code> 不会阻塞，立即返回。如果没有事件发生，则 <code>revents</code> 字段会被设置为 0。</li>
<li><strong>-1</strong>：表示无限期等待，<code>poll</code> 将会一直阻塞直到某个事件发生。</li>
</ul>
</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>返回值小于0, 表示出错；</li>
<li>返回值等于0, 表示poll函数等待超时；</li>
<li>返回值大于0, 表示poll由于监听的文件描述符就绪而返回</li>
</ul>
<h3 id="socket就绪条件"><a href="#socket就绪条件" class="headerlink" title="socket就绪条件"></a>socket就绪条件</h3><p>与<code>select</code>相同；</p>
<h3 id="poll-的优点"><a href="#poll-的优点" class="headerlink" title="poll 的优点"></a>poll 的优点</h3><p>较<code>select</code>来说，<strong>省略了三套位图结构</strong>，而以一个结构体指针类型代替，<strong>优化了数据存储的结构</strong>；</p>
<blockquote>
<ol>
<li>首先针对结构体提供了<strong>同一的操作接口</strong>，而不是<code>select</code>在循环中进行赋值操作；</li>
<li>与<code>select</code>的位图数组（大小由fd_set限制，而该限制是硬限制，可以通过修改系统设置来更改）不同，<code>poll</code>依赖于结构体数组实现，所以理论上<code>poll</code>没有最大数量的限制；</li>
</ol>
</blockquote>
<h3 id="poll-的缺点"><a href="#poll-的缺点" class="headerlink" title="poll 的缺点"></a>poll 的缺点</h3><ol>
<li>尽管poll通过结构体指针实现了操作的统一，但是<strong>之后的查询就绪状态依然需要执行遍历操作</strong>，尤其是当监视的文件描述符数量较大时，会带来较大的性能消耗；</li>
<li>内部使用数组维护，动态扩展和删除性能较差，系统需要重新构建一个<code>poll_fd</code>结构体数组，由此会带来较大的拷贝资源消耗；</li>
</ol>
<h3 id="poll-的使用实例（检测标准输入输出——ReadEvent-ListenEvent）"><a href="#poll-的使用实例（检测标准输入输出——ReadEvent-ListenEvent）" class="headerlink" title="poll 的使用实例（检测标准输入输出——ReadEvent &amp;&amp; ListenEvent）"></a>poll 的使用实例（检测标准输入输出——ReadEvent &amp;&amp; ListenEvent）</h3><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// For memset, strerror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// For close, read, write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// For exit, EXIT_FAILURE, EXIT_SUCCESS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">// For a more C++ idiomatic way if not restricted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// For std::remove_if with vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FDS = <span class="number">1024</span>;    <span class="comment">// Maximum number of file descriptors to monitor</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">1024</span>; <span class="comment">// Buffer for reading data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PollServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _listenFd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> _fds[MAX_FDS]; <span class="comment">// Array of pollfd structures</span></span><br><span class="line">    <span class="type">int</span> _numCurrentFds;          <span class="comment">// Number of actual FDs being monitored (optimization for poll)</span></span><br><span class="line">                                 <span class="comment">// Or, more simply, always poll MAX_FDS and let poll ignore fd = -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Socket helper functions (static as in original) ---</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;socket error: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Socket fd created: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Set port reuse</span></span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;setsockopt(SO_REUSEADDR) failed: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// Not exiting, but good to know</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;bind error on port &quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bind successful on fd: &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; to port &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog = <span class="number">5</span>)</span> <span class="comment">// Added backlog parameter with default</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(fd, backlog) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;listen error: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listen successful on fd: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> sock, std::string&amp; clientIp, <span class="type">uint16_t</span>&amp; clientPort)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">        <span class="type">int</span> clientFd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// EAGAIN or EWOULDBLOCK means no pending connections (if non-blocking accept)</span></span><br><span class="line">            <span class="comment">// For a blocking accept, this is a real error.</span></span><br><span class="line">            <span class="comment">// For poll, accept is typically called only when listen_fd is readable.</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">                 std::cerr &lt;&lt; <span class="string">&quot;accept error: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Indicate error or no connection</span></span><br><span class="line">        &#125;</span><br><span class="line">        clientIp = <span class="built_in">inet_ntoa</span>(client_addr.sin_addr);</span><br><span class="line">        clientPort = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Accepted new connection. Client fd: &quot;</span> &lt;&lt; clientFd</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; clientIp &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; clientPort &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> clientFd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Poll specific helpers ---</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddClientFd</span><span class="params">(<span class="type">int</span> clientFd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_FDS; ++i) &#123; <span class="comment">// Start from 1 because 0 is _listenFd</span></span><br><span class="line">            <span class="keyword">if</span> (_fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                _fds[i].fd = clientFd;</span><br><span class="line">                _fds[i].events = POLLIN; <span class="comment">// Monitor for readability</span></span><br><span class="line">                _fds[i].revents = <span class="number">0</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Added client fd &quot;</span> &lt;&lt; clientFd &lt;&lt; <span class="string">&quot; to poll set at index &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// _numCurrentFds can be used to optimize the second argument of poll</span></span><br><span class="line">                <span class="comment">// if we compact the array or track the highest index.</span></span><br><span class="line">                <span class="comment">// For simplicity, we&#x27;ll poll all MAX_FDS entries.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Too many clients. Cannot add fd: &quot;</span> &lt;&lt; clientFd &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(clientFd); <span class="comment">// Close if we can&#x27;t handle it</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveClientFd</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= MAX_FDS || _fds[index].fd == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Client fd &quot;</span> &lt;&lt; _fds[index].fd &lt;&lt; <span class="string">&quot; at index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; disconnected or error. Closing.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(_fds[index].fd);</span><br><span class="line">        _fds[index].fd = <span class="number">-1</span>;</span><br><span class="line">        _fds[index].events = <span class="number">0</span>;</span><br><span class="line">        _fds[index].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// To optimize poll&#x27;s second argument, you might compact the array here</span></span><br><span class="line">        <span class="comment">// or adjust _numCurrentFds if you are tracking the max index.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleNewConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::string clientIp;</span><br><span class="line">        <span class="type">uint16_t</span> clientPort;</span><br><span class="line">        <span class="type">int</span> clientFd = <span class="built_in">Accept</span>(_listenFd, clientIp, clientPort);</span><br><span class="line">        <span class="keyword">if</span> (clientFd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">AddClientFd</span>(clientFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleClientData</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> bytes_read = <span class="built_in">recv</span>(_fds[index].fd, buffer, BUFFER_SIZE <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Null-terminate</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received from fd &quot;</span> &lt;&lt; _fds[index].fd &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; buffer;</span><br><span class="line">            <span class="comment">// Simple echo server: send data back</span></span><br><span class="line">            <span class="built_in">send</span>(_fds[index].fd, buffer, bytes_read, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Connection closed by client</span></span><br><span class="line">            <span class="built_in">RemoveClientFd</span>(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error on recv</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123; <span class="comment">// EAGAIN for non-blocking</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;recv error on fd &quot;</span> &lt;&lt; _fds[index].fd &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">RemoveClientFd</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PollServer</span>(<span class="type">int</span> port) : _listenFd(<span class="number">-1</span>), _numCurrentFds(<span class="number">0</span>) &#123;</span><br><span class="line">        _listenFd = <span class="built_in">Socket</span>();</span><br><span class="line">        <span class="built_in">Bind</span>(_listenFd, port);</span><br><span class="line">        <span class="built_in">Listen</span>(_listenFd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize pollfd array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FDS; ++i) &#123;</span><br><span class="line">            _fds[i].fd = <span class="number">-1</span>; <span class="comment">// -1 indicates an unused entry</span></span><br><span class="line">            _fds[i].events = <span class="number">0</span>;</span><br><span class="line">            _fds[i].revents = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add listen_fd to the set</span></span><br><span class="line">        _fds[<span class="number">0</span>].fd = _listenFd;</span><br><span class="line">        _fds[<span class="number">0</span>].events = POLLIN; <span class="comment">// Monitor for incoming connections</span></span><br><span class="line">        <span class="comment">// _numCurrentFds = 1; // if tracking max index for poll&#x27;s 2nd arg</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;PollServer initialized. Listening on fd &quot;</span> &lt;&lt; _listenFd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">PollServer</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_listenFd != <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Closing listen fd: &quot;</span> &lt;&lt; _listenFd &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(_listenFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_FDS; ++i) &#123; <span class="comment">// Start from 1, 0 is listenFd</span></span><br><span class="line">            <span class="keyword">if</span> (_fds[i].fd != <span class="number">-1</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Closing client fd: &quot;</span> &lt;&lt; _fds[i].fd &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">close</span>(_fds[i].fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;PollServer shut down.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server starting poll loop...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="comment">// 直到连接断开</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// The second argument to poll is the number of items in the fds array.</span></span><br><span class="line">            <span class="comment">// If you optimize by compacting or tracking max index, this could be _numCurrentFds.</span></span><br><span class="line">            <span class="comment">// For simplicity, we pass MAX_FDS; poll ignores entries where fd is -1.</span></span><br><span class="line">            <span class="type">int</span> nready = <span class="built_in">poll</span>(_fds, MAX_FDS, <span class="number">-1</span>); <span class="comment">// -1 for infinite timeout</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINTR) <span class="keyword">continue</span>; <span class="comment">// Interrupted by signal, try again</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;poll error: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// Critical error</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nready == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Timeout occurred (if timeout was not -1)</span></span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; &quot;Poll timeout.&quot; &lt;&lt; std::endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check listen_fd first (it&#x27;s at index 0)</span></span><br><span class="line">            <span class="keyword">if</span> (_fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="built_in">HandleNewConnection</span>();</span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// Optimization: if all handled</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check client fds</span></span><br><span class="line">            <span class="comment">// 遍历式查找</span></span><br><span class="line">            <span class="comment">// 较高的时间复杂度, 特别是监听的fd数量很大时</span></span><br><span class="line">            <span class="comment">// poll的缺点之一</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_FDS; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_fds[i].fd == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// Skip unused entries</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_fds[i].revents &amp; (POLLIN | POLLERR | POLLHUP)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                        <span class="built_in">HandleClientData</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// POLLERR or POLLHUP might also be set along with POLLIN if error occurred after data arrived</span></span><br><span class="line">                    <span class="comment">// or if client closed write end (POLLIN for FIN) then fully closed (POLLHUP)</span></span><br><span class="line">                    <span class="keyword">if</span> (_fds[i].revents &amp; (POLLERR | POLLHUP)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(_fds[i].revents &amp; POLLIN)) &#123; <span class="comment">// If not already handled by HandleClientData reading 0</span></span><br><span class="line">                           std::cerr &lt;&lt; <span class="string">&quot;Error/Hangup on fd &quot;</span> &lt;&lt; _fds[i].fd &lt;&lt; <span class="string">&quot;. Events: &quot;</span> &lt;&lt; _fds[i].revents &lt;&lt; std::endl;</span><br><span class="line">                           <span class="built_in">RemoveClientFd</span>(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// Optimization: all handled events processed</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> port = DEFAULT_PORT;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Invalid port number: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">            port = DEFAULT_PORT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">PollServer <span class="title">server</span><span class="params">(port)</span></span>;</span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>——Linux 2.6 版本下公认的性能最好的多路 I&#x2F;O 就绪通知方法</p>
<h3 id="epoll-相关系统调用"><a href="#epoll-相关系统调用" class="headerlink" title="epoll 相关系统调用"></a>epoll 相关系统调用</h3><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><p>创建一个<code>epoll</code>句柄；</p>
<h5 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h5><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h5><ul>
<li>size：</li>
</ul>
<blockquote>
<ul>
<li><p>Linux 2.6.8 之前，<code>size</code> 参数用于指定内核为 epoll 实例分配的事件队列的大小。具体来说，它表示内核分配的事件数组的初始大小，即内核为该 epoll 实例保留的空间大小（以事件数量为单位）。如果事件的数量超过这个初始大小，内核会动态地扩展空间。</p>
</li>
<li><p>Linux 2.6.8 之后，size&#96; 参数的作用被弃用了；而内核根据实际需求来分配资源；</p>
</li>
</ul>
</blockquote>
<h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><ul>
<li><p><strong>成功</strong>：返回一个非负整数，表示创建的 epoll 实例的文件描述符。</p>
</li>
<li><p><strong>失败</strong>：如果调用失败，返回 <code>-1</code>，并且设置 <code>errno</code> 以指示错误原因。</p>
</li>
</ul>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><p><code>epoll</code>的事件注册函数；</p>
<h5 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h5><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *_Nullable event)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h5><p>epfd：epoll_create 的返回值，即 epoll 的句柄；</p>
<blockquote>
<p>什么是句柄？</p>
<ul>
<li><p>句柄是对资源的抽象引用，用来间接操作资源而不暴露资源的内部细节。</p>
</li>
<li><p>它通常由操作系统或库分配，并通过特定的 API 来进行资源的管理和访问。</p>
</li>
<li><p>句柄的常见应用包括文件、窗口、数据库连接和图形对象等。</p>
</li>
<li><p>句柄和指针的区别在于，指针直接访问内存，而句柄是资源的抽象标识符，底层实现和资源管理由操作系统或库负责。</p>
</li>
</ul>
</blockquote>
<p>op：表示具体的操作，具体分为一下三个宏：</p>
<ul>
<li><p>EPOLL_CTL_ADD：注册新的fd到epfd中</p>
</li>
<li><p>EPOLL_CTL_MOD：修改已经注册的fd的监听事件</p>
</li>
<li><p>EPOLL_CTL_DEL：从epfd中删除一个fd；</p>
</li>
<li><p>fd：表示需要监听的文件描述符；</p>
</li>
<li><p>event：表示内核需要监听的具体事件；</p>
</li>
</ul>
<p><em>struct epoll_event</em> 参数说明</p>
<p>其具体的结构如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;   <span class="comment">/* Epoll Event */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;__EPOLL_PACKED;</span><br></pre></td></tr></table></figure></div>

<p>events可以是下列宏的集合（因为是位图结构，所以支持位运算）</p>
<blockquote>
<ul>
<li><p>EPOLLIN：表示对应的文件描述符可读（包括对端SOCKET正常关闭）</p>
</li>
<li><p>EPOLLOUT：表示对应的文件描述符可写</p>
</li>
<li><p>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</p>
</li>
<li><p>EPOLLERR：表示对应的文件描述符发生错误</p>
</li>
<li><p>EPOLLHUP：表示对应的文件描述符被挂断</p>
</li>
<li><p>EPOLLET ：将EPOLL设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的；</p>
</li>
<li><p>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里;</p>
</li>
</ul>
</blockquote>
<p><em>边缘触发 &amp;&amp; 水平触发</em></p>
<ul>
<li><p>边缘触发</p>
<ul>
<li><p><em>解释</em></p>
<p>​    边缘触发是指当事件从未触发状态变为触发状态时，操作系统会通知应用程序一次。如果事件从未触发状态变为触发状态后，直到事件被清除（处理完成）之前，操作系统不会再通知应用程序。</p>
<p>​    也就是说，只有事件的“变化”才会触发通知。</p>
</li>
<li><p><em>特点</em></p>
<ul>
<li><strong>一次性通知</strong>：只有当事件的状态从非触发变为触发时，才会发出通知，之后事件不会再重复通知，除非应用程序明确地清除事件的状态（比如读取数据）。</li>
<li><strong>需要不断轮询</strong>：如果应用程序没有及时处理事件（例如，未读取网络数据），则需要不断地进行轮询或等待下一次事件通知。</li>
</ul>
</li>
<li><p><em>应用场景</em></p>
<p>​    边缘触发适用于对事件的处理非常迅速、并且应用程序能够及时清除事件状态的场景。</p>
</li>
</ul>
</li>
<li><p>水平触发</p>
<ul>
<li><p><em>解释</em></p>
<p>​    水平触发是指，当事件处于触发状态时，操作系统会持续地通知应用程序，直到事件被处理完成并恢复到非触发状态。与边缘触发不同，水平触发会持续发出通知，直到应用程序处理了事件。</p>
</li>
<li><p><em>特点</em></p>
<ul>
<li><strong>持续通知</strong>：只要事件的状态仍然是触发状态，操作系统就会持续通知应用程序。应用程序必须处理事件（例如读取数据）才能清除触发状态。</li>
<li><strong>不需要不断轮询</strong>：应用程序只需等待事件并处理它，而不需要担心遗漏重复的事件通知。</li>
</ul>
</li>
<li><p>应用场景</p>
<p>​    水平触发适用于事件状态可能持续存在的场景，且应用程序需要持续收到通知直到事件被处理的情况。</p>
</li>
</ul>
</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>收集在epoll监控的事件中已经发送的事件；</p>
<h5 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h5><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h5><ul>
<li><p>epfd:</p>
<p><code>epoll</code>的文件描述符，表示一个<code>epoll</code>实例，内部维护了多个文件描述符遗迹这些描述符的相关事件；</p>
</li>
<li><p>events:</p>
<p>一个指向<code>epoll_event</code>结构体数组的指针，用于存放<code>epoll_wait</code>返回的就绪事件；在调用 <code>epoll_wait</code> 时，系统会将就绪的事件写入这个数组。应用程序需要遍历这个数组，并处理每个就绪事件；</p>
<blockquote>
<p><code>struct epoll_event</code>的定义</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span> events;  <span class="comment">// 事件类型（例如，EPOLLIN, EPOLLOUT等）</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据（通常用于存储文件描述符的相关信息）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></blockquote>
<ul>
<li><strong><code>events</code></strong>：表示文件描述符的状态，<code>epoll_wait</code> 返回的事件类型，可能的值包括：<ul>
<li><code>EPOLLIN</code>：表示文件描述符可读。</li>
<li><code>EPOLLOUT</code>：表示文件描述符可写。</li>
<li><code>EPOLLERR</code>：表示文件描述符发生错误。</li>
<li><code>EPOLLHUP</code>：表示文件描述符挂起（例如，连接被断开）。</li>
<li>其他事件，如 <code>EPOLLRDHUP</code>（TCP连接关闭通知）等。</li>
</ul>
</li>
<li><strong><code>data</code></strong>：用户定义的数据，通常用于存储与文件描述符相关的信息。通过它可以区分不同的文件描述符或关联的业务逻辑。例如，存储一个指向自定义结构的指针，或者直接存储文件描述符本身。</li>
</ul>
</li>
<li><p>maxevents</p>
<p>这是 <code>events</code> 数组的大小，表示最多可以返回多少个就绪事件。<code>epoll_wait</code> 会返回最多 <code>maxevents</code> 个事件，这个数量不超过数组的大小;</p>
</li>
<li><p>timeout</p>
<p>指定 <code>epoll_wait</code> 等待事件的最大时间，单位为毫秒。该参数控制 <code>epoll_wait</code> 的等待行为；</p>
<ul>
<li><strong><code>timeout = -1</code></strong>：表示无限等待，直到有一个或多个事件就绪为止。<code>epoll_wait</code> 会阻塞直到有文件描述符发生变化（例如，变为可读、可写，或者发生错误等）。</li>
<li><strong><code>timeout = 0</code></strong>：表示非阻塞模式，<code>epoll_wait</code> 会立即返回，不会等待。它会检查所有注册的文件描述符的状态，如果没有就绪事件，会返回 <code>0</code>，表示当前没有文件描述符就绪。</li>
<li><strong><code>timeout &gt; 0</code></strong>：表示最多等待 <code>timeout</code> 毫秒，如果在指定时间内有就绪事件，<code>epoll_wait</code> 会返回；如果没有就绪事件，则在超时后返回 <code>0</code>。</li>
</ul>
<p><strong>常见应用场景</strong>：</p>
<ul>
<li><code>timeout = -1</code>：常用于需要等待直到事件发生的场景，如网络服务器等待连接或数据到来。</li>
<li><code>timeout = 0</code>：常用于非阻塞模式，通常在多线程或多任务的环境中，用来检查文件描述符的状态而不阻塞。</li>
<li><code>timeout &gt; 0</code>：适用于需要定时轮询事件的场景，例如，应用程序需要定期检查文件描述符的状态，并在超时后执行一些其他任务。</li>
</ul>
</li>
</ul>
<h5 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h5><ul>
<li><p><strong>成功</strong>：返回就绪的事件数量，表示有多少个文件描述符的事件发生了。这个数量可以小于或等于 <code>maxevents</code>，如果没有事件发生，则返回 <code>0</code>。如果有事件发生但返回的数量小于 <code>maxevents</code>，表示没有更多的就绪事件，程序可以继续处理其他任务。</p>
</li>
<li><p><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code> 来指示错误。常见的错误码包括：</p>
<ul>
<li><strong><code>EINTR</code></strong>：系统调用被信号中断，需要重新调用 <code>epoll_wait</code>。</li>
<li><strong><code>EBADF</code></strong>：<code>epfd</code> 不是一个有效的文件描述符。</li>
<li><strong><code>EINVAL</code></strong>：无效的参数，可能是 <code>events</code> 为 NULL 或 <code>maxevents</code> 非法等。</li>
</ul>
</li>
</ul>
<h3 id="epoll完整代码实例"><a href="#epoll完整代码实例" class="headerlink" title="epoll完整代码实例"></a>epoll完整代码实例</h3><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// for memset, strerror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for exit, atoi</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_EVENTS = <span class="number">10</span>;      <span class="comment">// epoll_wait 一次最多处理的事件数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">1024</span>;   <span class="comment">// 读写缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEFAULT_PORT = <span class="number">8080</span>;  <span class="comment">// 默认端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;fcntl(F_GETFL) 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;fcntl(F_SETFL) 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Epoll 服务器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpollServer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _listenFd;   <span class="comment">// 监听套接字</span></span><br><span class="line">    <span class="type">int</span> _epollFd;    <span class="comment">// epoll 实例的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 套接字辅助函数 ---</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;socket 创建失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Socket fd 创建成功: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 设置端口复用</span></span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;setsockopt(SO_REUSEADDR) 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;bind 错误，端口 &quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bind 成功，fd: &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 到端口 &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog = <span class="number">128</span>)</span> </span>&#123; <span class="comment">// 增加 backlog</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(fd, backlog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;listen 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listen 成功，fd: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Epoll 特定辅助函数 ---</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_fd_to_epoll</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = events;</span><br><span class="line">        ev.data.fd = fd;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(_epollFd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;epoll_ctl 添加 fd &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 根据情况处理，例如关闭fd</span></span><br><span class="line">            <span class="keyword">if</span> (fd != _listenFd &amp;&amp; fd != STDIN_FILENO) &#123; <span class="comment">// 不要关闭监听fd和标准输入</span></span><br><span class="line">                <span class="built_in">close</span>(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;fd &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 已添加到 epoll 监视，事件: &quot;</span> &lt;&lt; events &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_fd_from_epoll</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(_epollFd, EPOLL_CTL_DEL, fd, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;epoll_ctl 删除 fd &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;fd &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 已从 epoll 监视中移除。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(fd); <span class="comment">// 确保关闭文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_new_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 对于非阻塞的server_fd，需要循环accept</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">            <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">            <span class="type">int</span> client_fd = <span class="built_in">accept</span>(_listenFd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                    <span class="comment">// 所有等待的连接都已处理完毕</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;accept 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 其他错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;接受新连接，来自 &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; <span class="string">&quot;，新 fd: &quot;</span> &lt;&lt; client_fd &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set_nonblocking</span>(client_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">close</span>(client_fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加新的客户端连接到 epoll，使用边缘触发(ET)和一次性触发(EPOLLONESHOT)</span></span><br><span class="line">            <span class="comment">// EPOLLONESHOT 使得一个fd上的事件只被触发一次，之后需要通过epoll_ctl EPOLL_CTL_MOD重新注册</span></span><br><span class="line">            <span class="comment">// 这对于多线程处理单个fd非常有用，防止竞争。对于单线程循环读取，可以不加。</span></span><br><span class="line">            <span class="comment">// 这里为了演示ET，加上EPOLLIN | EPOLLET</span></span><br><span class="line">            <span class="built_in">add_fd_to_epoll</span>(client_fd, EPOLLIN | EPOLLET);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_client_data</span><span class="params">(<span class="type">int</span> client_fd)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        std::vector&lt;<span class="type">char</span>&gt; total_data; <span class="comment">// 使用 vector 动态存储数据</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理来自 fd &quot;</span> &lt;&lt; client_fd &lt;&lt; <span class="string">&quot; 的数据...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ET 模式下，需要循环读取直到 EAGAIN/EWOULDBLOCK</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ssize_t</span> bytes_read = <span class="built_in">read</span>(client_fd, buffer, BUFFER_SIZE <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 仅用于调试打印</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;  读取到 &quot;</span> &lt;&lt; bytes_read &lt;&lt; <span class="string">&quot; 字节: &#x27;&quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                total_data.<span class="built_in">insert</span>(total_data.<span class="built_in">end</span>(), buffer, buffer + bytes_read);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 客户端关闭连接 (EOF)</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;客户端 fd &quot;</span> &lt;&lt; client_fd &lt;&lt; <span class="string">&quot; 关闭了连接。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">remove_fd_from_epoll</span>(client_fd); <span class="comment">// 从epoll移除并关闭</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 处理完毕</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// bytes_read == -1</span></span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                    <span class="comment">// 非阻塞模式下，数据已读完</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;  fd &quot;</span> &lt;&lt; client_fd &lt;&lt; <span class="string">&quot; 数据已读完 (EAGAIN/EWOULDBLOCK)。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 发生其他读取错误</span></span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;read 从 fd &quot;</span> &lt;&lt; client_fd &lt;&lt; <span class="string">&quot; 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">remove_fd_from_epoll</span>(client_fd); <span class="comment">// 从epoll移除并关闭</span></span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 处理完毕</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!total_data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 回显数据</span></span><br><span class="line">            <span class="type">ssize_t</span> bytes_written_total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(bytes_written_total &lt; total_data.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(client_fd, total_data.<span class="built_in">data</span>() + bytes_written_total, total_data.<span class="built_in">size</span>() - bytes_written_total);</span><br><span class="line">                <span class="keyword">if</span>(bytes_written &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    bytes_written_total += bytes_written;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)&#123;</span><br><span class="line">                        <span class="comment">// 发送缓冲区满，可以考虑用 EPOLLOUT 来处理这种情况</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;  fd &quot;</span> &lt;&lt; client_fd &lt;&lt; <span class="string">&quot; 发送缓冲区满，稍后重试或使用 EPOLLOUT。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="comment">// 对于ET模式，如果想确保数据完全写完，需要将此fd注册EPOLLOUT事件</span></span><br><span class="line">                        <span class="comment">// 这里简单处理，丢弃未写完的数据或等待下次触发</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;write 到 fd &quot;</span> &lt;&lt; client_fd &lt;&lt; <span class="string">&quot; 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                        <span class="built_in">remove_fd_from_epoll</span>(client_fd);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// bytes_written == 0, 理论上不应该发生除非size为0</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已回显 &quot;</span> &lt;&lt; bytes_written_total &lt;&lt; <span class="string">&quot; 字节到 fd &quot;</span> &lt;&lt; client_fd &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果使用了 EPOLLONESHOT，处理完后需要重新 arm (MOD)</span></span><br><span class="line">        <span class="comment">// add_fd_to_epoll(client_fd, EPOLLIN | EPOLLET | EPOLLONESHOT); // 假设 add_fd_to_epoll 内部处理 MOD</span></span><br><span class="line">        <span class="comment">// 或者直接：</span></span><br><span class="line">        <span class="comment">// struct epoll_event ev;</span></span><br><span class="line">        <span class="comment">// ev.events = EPOLLIN | EPOLLET; // 根据是否使用EPOLLONESHOT决定</span></span><br><span class="line">        <span class="comment">// ev.data.fd = client_fd;</span></span><br><span class="line">        <span class="comment">// if (epoll_ctl(_epollFd, EPOLL_CTL_MOD, client_fd, &amp;ev) == -1) &#123;</span></span><br><span class="line">        <span class="comment">//     perror(&quot;epoll_ctl: mod client_fd&quot;);</span></span><br><span class="line">        <span class="comment">//     remove_fd_from_epoll(client_fd);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_stdin_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="comment">// 标准输入通常是阻塞的，除非也设为非阻塞</span></span><br><span class="line">        <span class="comment">// 这里假设是阻塞读取一次</span></span><br><span class="line">        <span class="type">ssize_t</span> bytes_read = <span class="built_in">read</span>(STDIN_FILENO, buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;从标准输入收到: &quot;</span> &lt;&lt; buffer; <span class="comment">// printf会自动加换行，cout不会</span></span><br><span class="line">            <span class="comment">// 如果标准输入的内容是&quot;quit&quot;，则退出服务器</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;收到 quit 命令，服务器将关闭...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 触发一个标志让主循环退出，或者直接exit</span></span><br><span class="line">                <span class="comment">// 这里简单起见，直接影响主循环（不推荐在真实应用中这样做）</span></span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Shutdown command received&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;标准输入 EOF，将不再监听标准输入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(_epollFd, EPOLL_CTL_DEL, STDIN_FILENO, <span class="literal">nullptr</span>); <span class="comment">// 不再监听标准输入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;read 从标准输入错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EpollServer</span>(<span class="type">int</span> port) : _listenFd(<span class="number">-1</span>), _epollFd(<span class="number">-1</span>) &#123;</span><br><span class="line">        _listenFd = <span class="built_in">Socket</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set_nonblocking</span>(_listenFd) == <span class="number">-1</span>) &#123; <span class="comment">// 监听套接字也设为非阻塞，配合循环accept</span></span><br><span class="line">            <span class="built_in">close</span>(_listenFd);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Bind</span>(_listenFd, port);</span><br><span class="line">        <span class="built_in">Listen</span>(_listenFd);</span><br><span class="line"></span><br><span class="line">        _epollFd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>); <span class="comment">// flags为0表示和epoll_create(size)行为类似，size被忽略</span></span><br><span class="line">        <span class="keyword">if</span> (_epollFd == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;epoll_create1 失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(_listenFd);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听套接字到 epoll，通常使用水平触发(LT)处理新连接更简单</span></span><br><span class="line">        <span class="comment">// 如果用ET，则accept需要循环处理</span></span><br><span class="line">        <span class="built_in">add_fd_to_epoll</span>(_listenFd, EPOLLIN); <span class="comment">// LT模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加标准输入到 epoll</span></span><br><span class="line">        <span class="comment">// if (set_nonblocking(STDIN_FILENO) == -1) &#123; // 如果想非阻塞读标准输入</span></span><br><span class="line">        <span class="comment">//     std::cerr &lt;&lt; &quot;无法设置标准输入为非阻塞&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">add_fd_to_epoll</span>(STDIN_FILENO, EPOLLIN); <span class="comment">// 假设标准输入是LT模式</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;EpollServer 初始化完成。正在监听 fd &quot;</span> &lt;&lt; _listenFd &lt;&lt; <span class="string">&quot; 和标准输入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">EpollServer</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_listenFd != <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;关闭监听 fd: &quot;</span> &lt;&lt; _listenFd &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(_listenFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_epollFd != <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;关闭 epoll fd: &quot;</span> &lt;&lt; _epollFd &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(_epollFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：在epoll实例关闭前，所有注册的fd理论上应该已经被epoll_ctl_del移除了</span></span><br><span class="line">        <span class="comment">// 或者在迭代处理时关闭的。这里只是确保主要的fd被关闭。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;EpollServer 关闭。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;服务器启动 epoll 循环...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(_epollFd, events, MAX_EVENTS, <span class="number">-1</span>); <span class="comment">// -1 表示无限等待</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINTR) <span class="keyword">continue</span>; <span class="comment">// 被信号中断，重试</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;epoll_wait 错误: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 严重错误</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> current_fd = events[i].data.fd;</span><br><span class="line">                <span class="type">uint32_t</span> current_events = events[i].events;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (current_events &amp; (EPOLLERR | EPOLLHUP)) &#123;</span><br><span class="line">                    <span class="comment">// 发生错误或挂断</span></span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;fd &quot;</span> &lt;&lt; current_fd &lt;&lt; <span class="string">&quot; 发生错误或挂断事件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">if</span> (current_fd != _listenFd &amp;&amp; current_fd != STDIN_FILENO) &#123;</span><br><span class="line">                        <span class="built_in">remove_fd_from_epoll</span>(current_fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 对于监听套接字或标准输入的错误，可能需要更特殊的处理</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (current_fd == _listenFd) &#123;</span><br><span class="line">                    <span class="comment">// 有新的连接请求</span></span><br><span class="line">                    <span class="keyword">if</span> (current_events &amp; EPOLLIN) &#123;</span><br><span class="line">                        <span class="built_in">handle_new_connection</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_fd == STDIN_FILENO) &#123;</span><br><span class="line">                    <span class="comment">// 标准输入有数据</span></span><br><span class="line">                    <span class="keyword">if</span> (current_events &amp; EPOLLIN) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="built_in">handle_stdin_data</span>();</span><br><span class="line">                        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">                            std::cerr &lt;&lt; <span class="string">&quot;处理标准输入时发生异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">                            running = <span class="literal">false</span>; <span class="comment">// 停止服务器</span></span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// 退出for循环</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是已连接的客户端套接字</span></span><br><span class="line">                    <span class="keyword">if</span> (current_events &amp; EPOLLIN) &#123;</span><br><span class="line">                        <span class="comment">// 有数据可读</span></span><br><span class="line">                        <span class="built_in">handle_client_data</span>(current_fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 还可以处理EPOLLOUT事件，如果之前发送时遇到EAGAIN</span></span><br><span class="line">                    <span class="comment">// if (current_events &amp; EPOLLOUT) &#123;</span></span><br><span class="line">                    <span class="comment">//    handle_client_write(current_fd);</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!running) <span class="keyword">break</span>; <span class="comment">// 如果收到退出命令</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> port = DEFAULT_PORT;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;无效的端口号: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">            port = DEFAULT_PORT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">EpollServer <span class="title">server</span><span class="params">(port)</span></span>;</span><br><span class="line">        server.<span class="built_in">Start</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;服务器运行时发生未捕获的异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三种多路复用技术的对比"><a href="#三种多路复用技术的对比" class="headerlink" title="三种多路复用技术的对比"></a>三种多路复用技术的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FD 存储</strong></td>
<td>fd_set 位图</td>
<td>pollfd 结构体数组</td>
<td>内核维护 (<code>红黑树</code>管理所有FD，<code>链表</code>管理就绪FD)</td>
</tr>
<tr>
<td><strong>最大连接数</strong></td>
<td>FD_SETSIZE (通常 1024)</td>
<td>无硬性限制 (受限于内存)</td>
<td>无硬性限制 (受限于内存, 远大于前两者)</td>
</tr>
<tr>
<td><strong>内核&#x2F;用户拷贝</strong></td>
<td>每次调用都拷贝 fd_set</td>
<td>每次调用都拷贝 pollfd 数组</td>
<td>epoll_ctl 时拷贝一次, <strong>epoll_wait 可能使用共享内存 (mmap)</strong></td>
</tr>
<tr>
<td><strong>效率&#x2F;扫描方式</strong></td>
<td>每次轮询所有 FD (<code>O(N)</code>)</td>
<td>每次轮询所有 FD (<code>O(N)</code>)</td>
<td>只返回就绪的 FD, 事件驱动 (<code>O(K)，K为就绪FD数</code>)</td>
</tr>
<tr>
<td><strong>返回就绪FD</strong></td>
<td>修改传入的 fd_set</td>
<td>不修改, 通过 revents 成员返回</td>
<td>返回就绪 FD 列表</td>
</tr>
<tr>
<td><strong>触发模式</strong></td>
<td>水平触发 (LT)</td>
<td>水平触发 (LT)</td>
<td><code>水平触发 (LT)</code> 和<code>边缘触发 (ET)</code></td>
</tr>
<tr>
<td><strong>线程安全 (指对监控集合的修改)</strong></td>
<td>不安全 (若多线程共享并修改同一个fd_set，需要外部同步)</td>
<td>相对安全 (每个线程可以有自己的pollfd数组，或对共享数组同步)</td>
<td><strong>epoll_ctl 操作是原子性的</strong>，<strong>epfd 本身是线程安全的</strong></td>
</tr>
<tr>
<td><strong>可移植性</strong></td>
<td>好 (POSIX)</td>
<td>好 (POSIX)</td>
<td>差 (Linux 特有)</td>
</tr>
</tbody></table>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Linux高级IO模型</li>
        <li><strong>作者:</strong> The Redefine Team</li>
        <li><strong>创建于
                :</strong> 2024-12-05 13:26:00</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-05-20 00:55:10
            </li>
        
        <li>
            <strong>链接:</strong> https://redefine.ohevan.com/2024/12/05/Linux高级IO模型/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Linux/">#Linux</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/12/07/%E4%BB%BF%E5%87%BD%E6%95%B0%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">仿函数和Lambda表达式</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/12/04/MySQL%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">MySQL 中的常见日志类型</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://blogcomment-virid.vercel.app/',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">Linux高级IO模型</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E7%BD%91%E7%BB%9C%E9%AB%98%E7%BA%A7-IO"><span class="nav-text">Linux 网络高级 IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-text">五种IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7IO%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-text">高级IO重要概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1-synchronous-communication-VS-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1-asynchronous-communication"><span class="nav-text">同步通信 (synchronous communication) VS 异步通信 (asynchronous communication)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E-VS-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text">阻塞 VS 非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7IO"><span class="nav-text">其他高级IO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-text">非阻塞IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl"><span class="nav-text">fcntl</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="nav-text">I&#x2F;O多路转接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Select"><span class="nav-text">Select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86select"><span class="nav-text">初识select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">select 函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">select 函数执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%B0%B1%E7%BB%AA%E6%9D%A1%E4%BB%B6"><span class="nav-text">select 就绪条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">select 的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">select 的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-text">select 的使用实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poll"><span class="nav-text">poll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E5%B0%B1%E7%BB%AA%E6%9D%A1%E4%BB%B6"><span class="nav-text">socket就绪条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">poll 的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">poll 的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%88%E6%A3%80%E6%B5%8B%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94ReadEvent-ListenEvent%EF%BC%89"><span class="nav-text">poll 的使用实例（检测标准输入输出——ReadEvent &amp;&amp; ListenEvent）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">epoll 相关系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><span class="nav-text">epoll完整代码实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">三种多路复用技术的对比</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">The Redefine Team</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 12 篇文章
                    </span>
                    
                        <span>
                            共 50.6k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
            <div class="icp-info my-1"><a target="_blank" rel="nofollow" href="
                
                    https://beian.miit.gov.cn/
                
                ">皖ICP备2024065853号-1</a></div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>





    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>