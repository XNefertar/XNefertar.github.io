<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="The Redefine Team">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://xnefertar.github.io/2024/12/17/详解tcp协议的可靠性传输实现/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP协议是如何实现可靠性传输的">
<meta property="og:url" content="http://xnefertar.github.io/2024/12/17/%E8%AF%A6%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xnefertar.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2024-12-17T05:14:00.000Z">
<meta property="article:modified_time" content="2025-05-15T04:09:55.482Z">
<meta property="article:author" content="XNefertar">
<meta property="article:tag" content="NetWork">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xnefertar.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            TCP协议是如何实现可靠性传输的 | XNefertar&#39;s Blog
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"xnefertar.github.io","root":"/","language":"zh-CN"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"atom-one-light","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Hello World!","subtitle":{"text":["Like a poem, so should be a program."],"hitokoto":{"enable":false,"show_author":true,"api":"https://v1.hitokoto.cn"},"typing_speed":80,"backing_speed":50,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"github":{"icon":"fa-solid fa-link","path":"/links/"},"Tags":{"icon":"fa-solid fa-tags","path":"/tags/"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/X.png" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                XNefertar&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links/"
                                        >
                                    <i class="fa-solid fa-link fa-fw"></i>
                                    GITHUB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links/"
                        >
                            <span>
                                GITHUB
                            </span>
                            
                                <i class="fa-solid fa-link fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">13</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">TCP协议是如何实现可靠性传输的</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">The Redefine Team</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-12-17 13:14</span>
        <span class="mobile">2024-12-17 13:14</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-05-15 12:09:55</span>
            <span class="mobile">2025-05-15 12:09:55</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/NetWork/">NetWork</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>11.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>42 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="TCP协议是如何实现可靠性传输的"><a href="#TCP协议是如何实现可靠性传输的" class="headerlink" title="TCP协议是如何实现可靠性传输的"></a>TCP协议是如何实现可靠性传输的</h1><p>TCP（Transmission Control Protocol，传输控制协议）是一个具有可靠性传输、面向字节流、面向连接、全双工通信的传输层协议，这里我们主要介绍其可靠性传输特点以及具体的实现方式。</p>
<p>本文分为一下几点进行介绍：</p>
<ol>
<li><strong><a href="#%E5%BA%8F%E5%88%97%E5%8F%B7%E4%B8%8E%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94">序列号（Sequence Numbers）与确认应答（Acknowledgements - ACKs）机制</a></strong></li>
<li><strong><a href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">重传机制（Retransmission）</a></strong><ol>
<li><strong><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">超时重传 （Timeout Retransmission）</a></strong></li>
<li><strong><a href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0">快速重传 （Fast Retransmit）</a></strong></li>
</ol>
</li>
<li><strong><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6">滑动窗口机制</a></strong></li>
<li><strong><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制（Congestion Control，基于Sender端的滑动窗口实现）</a></strong></li>
<li><strong><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制（Flow Control，基于Receiver端的滑动窗口实现）</a></strong></li>
<li><strong><a href="#%E6%A0%A1%E9%AA%8C%E5%92%8C">校验和（Checksum）</a></strong></li>
<li><strong><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理（Connection Management）</a></strong></li>
</ol>
<h2 id="序列号与确认应答"><a href="#序列号与确认应答" class="headerlink" title="序列号与确认应答"></a>序列号与确认应答</h2><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>TCP是一种<strong>面向字节流的协议</strong>。这意味着TCP将应用程序<strong>传输的数据看作是一个连续的、无结构的字节序列</strong>。</li>
<li>为了管理和追踪这些字节，TCP会为整个字节流中的 <strong>每一个字节</strong> 都编上一个唯一的序号。</li>
<li>在TCP段（Segment）的头部，有一个<strong>32位的<code>序列号</code>字段</strong>。这个字段包含的值 <strong>不是</strong> 该段数据的字节数或段的编号，而是该TCP段所携带的 <strong>第一个数据字节</strong> 在整个字节流中的序号。</li>
</ul>
<h4 id="初始序列号-Initial-Sequence-Number-ISN"><a href="#初始序列号-Initial-Sequence-Number-ISN" class="headerlink" title="初始序列号 (Initial Sequence Number, ISN)"></a>初始序列号 (Initial Sequence Number, ISN)</h4><ul>
<li>当建立一个新的TCP连接时（三次握手期间），通信双方（客户端和服务器）各自<strong>会选择一个初始序列号（ISN</strong>）。</li>
<li>这个ISN <strong>不是</strong> 从0或1开始的固定值，而是<strong>基于一个随时间变化的计时器</strong>（通常每4微秒加1）<strong>或其他方法生成的</strong>，使其<strong>具有一定的随机性</strong>。这样做主要是为了安全，防止旧连接的报文被误认为是新连接的报文，以及<strong>防止序列号被预测</strong>而发起的攻击。</li>
<li>双方通过三次握手的<code>SYN</code>和<code>SYN-ACK报文</code><strong>交换各自的ISN，并确认对方的ISN</strong>。</li>
</ul>
<h4 id="序列号的递增"><a href="#序列号的递增" class="headerlink" title="序列号的递增"></a>序列号的递增</h4><ul>
<li>一旦连接建立，发送方发送数据时，后续TCP段的序列号会<strong>基于已发送的数据量进行递增</strong>。</li>
<li>例如：如果一方选择的ISN是 <code>X</code>，它发送的第一个TCP段包含1000字节的数据，那么该段的序列号就是 <code>X</code>。如果下一个段紧接着这1000字节发送，并且包含500字节的数据，那么第二个段的序列号就是 <code>X + 1000</code>。</li>
<li>即使TCP段不携带数据（例如<strong>纯ACK段</strong>），有时<strong>也可能消耗一个序列号</strong>（如SYN和FIN段），但通常携带数据的段的序列号是根据其数据部分的第一个字节来确定的。<ul>
<li><strong>普通数据段</strong>：<ul>
<li>序列号 &#x3D; 该段中第一个字节在整个数据流中的位置</li>
<li>每个数据字节占用一个序列号</li>
</ul>
</li>
<li><strong>特殊控制段</strong>：<ul>
<li><strong>SYN段</strong>：建立连接时发送，消耗1个序列号位置</li>
<li><strong>FIN段</strong>：关闭连接时发送，消耗1个序列号位置</li>
<li>这意味着即使这些段不携带实际数据，它们仍然会导致后续段的序列号增加1</li>
</ul>
</li>
<li><strong>纯ACK段</strong>：<ul>
<li>只包含确认信息，不携带数据</li>
<li>通常<strong>不消耗</strong>序列号</li>
<li>其序列号字段值通常是发送方下一个要发送的数据字节序列号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>保证数据有序性：</strong> 接收方根据TCP段的序列号来重新组装数据，即使这些段在网络中是乱序到达的，也能恢复成原始的、有序的字节流。</li>
<li><strong>检测丢失数据：</strong> 接收方可以通过检查收到的序列号是否连续来判断是否有数据段丢失。例如，收到了<code>Seq=1000</code>的段和<code>Seq=3000</code>的段，但没收到<code>Seq=2000</code>的段，就知道中间丢失了数据。</li>
<li><strong>去除重复数据：</strong> 如果接收方收到了具有相同序列号范围的数据段（通常是由于重传导致），它可以根据序列号识别出这是重复数据并丢弃它。</li>
</ul>
<h3 id="确认应答"><a href="#确认应答" class="headerlink" title="确认应答"></a>确认应答</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>确认应答是TCP实现可靠性的<strong>关键反馈机制</strong>。接收方使用ACK来告知发送方它已经成功收到了哪些数据。</p>
</li>
<li><p>TCP头部也有一个<strong>32位的<code>确认号</code> (Acknowledgement Number)</strong> 字段。</p>
</li>
<li><p>同时，TCP头部还有一个<code>ACK</code>标志位 (Flag)。当这个标志位被设置为1时，表示确认号字段有效；否则，确认号字段无效。</p>
</li>
</ul>
<p><strong>在连接建立之后，几乎所有发送的TCP段都会设置ACK标志位。</strong></p>
<h4 id="确认号的含义（重点）"><a href="#确认号的含义（重点）" class="headerlink" title="&#x3D;&#x3D;确认号的含义（重点）&#x3D;&#x3D;"></a>&#x3D;&#x3D;确认号的含义（重点）&#x3D;&#x3D;</h4><ul>
<li>TCP的ACK是 <strong>累积确认 (Cumulative Acknowledgement)</strong> 的。</li>
<li>确认号字段的值 <strong>不是</strong> 对刚刚收到的那个段的确认，而是表示 <strong>“我已经成功接收到序号为 <code>N-1</code>（含）之前的所有字节，现在我期望接收的下一个字节的序号是 <code>N</code>”</strong>。</li>
<li>例如：发送方发送了三个段，Seq分别为 1, 101, 201 (假设每个段100字节)。接收方收到了<code>Seq=1</code>和<code>Seq=101</code>的段，它会发送一个ACK段，其确认号 (Ack Number) 设置为 <code>201</code>。这表示：<code>序号在201之前的所有字节（即1到200）我都收到了，请从序号201开始发送</code>。</li>
</ul>
<h4 id="ACK的发送时机"><a href="#ACK的发送时机" class="headerlink" title="ACK的发送时机"></a>ACK的发送时机</h4><ul>
<li><strong>捎带确认 (Piggybacking):</strong> 如果接收方正好有数据要发送给对方，它通常会将ACK信息“捎带”在它发送的数据段中（设置ACK位并填写确认号），这样可以节省网络带宽。</li>
<li><strong>延迟确认 (Delayed ACK):</strong> 如果接收方没有数据要立即发送，它通常不会为每个收到的数据段都立刻发送一个单独的ACK段。它可能会稍等片刻（例如，几十到几百毫秒），看是否有多个段可以一次性确认，或者是否有数据可以捎带确认。这可以减少网络中的ACK报文数量，但可能略微增加传输延迟。<strong>规范通常建议最多延迟对一个数据段的确认</strong>。</li>
<li><strong>收到乱序段时：</strong> 当接收方收到一个乱序的数据段（即Seq号大于期望收到的序号），它会 <strong>立即</strong> 发送一个重复的ACK，该ACK的<strong>确认号仍然是它当前期望收到的那个最小序号</strong>。</li>
</ul>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>确认数据接收：</strong> 让发送方知道哪些数据已经被对方成功接收。</li>
<li><strong>触发数据发送&#x2F;窗口滑动：</strong> 发送方收到ACK后，可以认为被确认的数据已经成功送达，可以将这些数据从发送缓存中移除（或标记为已确认），并根据接收方的窗口通告（包含在ACK段中）继续发送新的数据（滑动发送窗口）。</li>
<li><strong>检测丢失数据（通过重复ACK）：</strong> 当发送方连续收到三个或更多具有相同确认号的ACK（称为“重复ACK”或“Duplicate ACKs”）时，它强烈暗示该确认号对应的那个数据段很可能在网络中丢失了。这会触发“快速重传”机制，让发送方在等待超时之前就重发丢失的段。</li>
</ul>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><h4 id="机制原理"><a href="#机制原理" class="headerlink" title="机制原理"></a>机制原理</h4><ul>
<li>这是TCP处理数据丢失的 <strong>最基本、最核心</strong> 的机制，可以看作是最后的<code>安全网</code>。</li>
<li>当TCP发送方发送一个数据段（Segment）后，它会为这个数据段启动一个 <strong>重传计时器 (Retransmission Timer)</strong>。</li>
<li>发送方期望在计时器超时之前收到接收方对该数据段的确认（ACK）。这个确认可以是直接确认该段，也可以是通过确认后续数据段而实现的累积确认。</li>
<li>如果在计时器到期时，发送方 <strong>仍未收到</strong> 对该数据段的有效确认，发送方就会 <strong>假定</strong> 该数据段在网络中丢失了（或者确认该数据段的ACK丢失了）。</li>
<li>此时，发送方就会 <strong>重新发送</strong> 那个被认为丢失的数据段。</li>
</ul>
<h4 id="重传超时时间-Retransmission-Timeout-RTO"><a href="#重传超时时间-Retransmission-Timeout-RTO" class="headerlink" title="重传超时时间 (Retransmission Timeout, RTO)"></a>重传超时时间 (Retransmission Timeout, RTO)</h4><ul>
<li>这个计时器的时长，即<code>RTO</code>，的设定至关重要。<ul>
<li><strong>太短：</strong> 可能导致不必要的重传。网络可能只是暂时拥堵导致延迟，数据并未丢失，过早重传会浪费带宽，甚至加剧拥塞。</li>
<li><strong>太长：</strong> 会导致数据丢失后需要等待很长时间才进行重传，降低了数据传输的效率和吞吐量。</li>
</ul>
</li>
<li><strong>动态计算RTO</strong>：TCP的RTO是<strong>动态调整</strong>的，它基于对**网络往返时间 (Round-Trip Time, RTT)**的持续测量和估计。<ul>
<li>TCP会测量发送数据段到接收到其确认之间的时间（<code>RTT样本</code>）。</li>
<li>它使用复杂的算法（如<strong>Jacobson&#x2F;Karels算法</strong>）来平滑RTT样本，计算出 <strong>平滑RTT (Smoothed RTT, SRTT)</strong> 和 <strong>RTT方差 (RTT Variation, RTTVAR)</strong>。</li>
<li>RTO通常设置为 <code>SRTT + 4 * RTTVAR</code>。这个公式考虑了平均延迟和延迟的抖动，提供了一个相对健壮的超时估算。</li>
<li>RTO有一个<strong>最小值</strong>（通常至少几百毫秒）和一个<strong>最大值限制</strong>。</li>
</ul>
</li>
</ul>
<h4 id="指数退避-Exponential-Backoff"><a href="#指数退避-Exponential-Backoff" class="headerlink" title="指数退避 (Exponential Backoff)"></a>指数退避 (Exponential Backoff)</h4><ul>
<li>如果一个数据段发生了超时重传，TCP通常会将其<strong>下一次重传的RTO值加倍</strong>（例如，变成原来的2倍、4倍、8倍…），直到达到一个上限。</li>
<li>这种“指数退避”策略的目的是：如果超时是由于网络拥塞引起的，快速连续地重传只会让网络更加拥堵。<strong>通过延长等待时间，给网络一个恢复的机会</strong>。</li>
<li>一旦收到了对重传数据的确认，RTO的计算会<strong>恢复到基于SRTT和RTTVAR的正常方式</strong>。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>超时重传的主要缺点是<strong>反应较慢</strong>。必须<strong>等待整个RTO时间</strong>过去才能发现和处理丢包，尤其在RTT较大的网络中，这个等待时间可能很长，<strong>导致连接<code>停顿</code>，吞吐量显著下降</strong>。</li>
</ul>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><h4 id="机制原理-1"><a href="#机制原理-1" class="headerlink" title="机制原理"></a>机制原理</h4><ul>
<li>快速重传机制旨在 <strong>更快地</strong> 检测和恢复丢失的数据段，尤其是在只有少量数据段丢失，而其后的数据段仍然能够到达接收方的情况下。它是一种优化，试图避免等待漫长的RTO。</li>
<li>它的触发条件 <strong>不是计时器超时</strong>，而是发送方 <strong>收到</strong> 了来自接收方的 <strong>重复确认 (Duplicate ACKs)</strong>。</li>
</ul>
<h4 id="重复确认-Duplicate-ACKs"><a href="#重复确认-Duplicate-ACKs" class="headerlink" title="重复确认 (Duplicate ACKs)"></a>重复确认 (Duplicate ACKs)</h4><ul>
<li>当接收方收到一个 <strong>乱序</strong> 的数据段（即序列号大于当前期望收到的序列号）时，根据TCP的累积确认规则，它无法确认这个乱序段。</li>
<li>此时，接收方会 <strong>立即</strong> 发送一个ACK，其确认号仍然是它 <strong>当前正在等待的那个最小序列号</strong>。</li>
<li>如果发送方发送了Seq&#x3D;100, 200, 300, 400, 500 的段，但Seq&#x3D;200丢失了。<ul>
<li>接收方收到Seq&#x3D;100，发送ACK&#x3D;200。</li>
<li>接收方收到Seq&#x3D;300（乱序），发送ACK&#x3D;200（重复ACK 1）。</li>
<li>接收方收到Seq&#x3D;400（乱序），发送ACK&#x3D;200（重复ACK 2）。</li>
<li>接收方收到Seq&#x3D;500（乱序），发送ACK&#x3D;200（重复ACK 3）。</li>
</ul>
</li>
<li>这些<code>ACK=200</code>的确认被称为重复确认，因为它们都在重复确认<code>Seq=100</code>及之前的数据。</li>
</ul>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul>
<li>TCP发送方通常在 <strong>连续收到三个或以上</strong> 的重复ACK时，会触发快速重传机制。（即收到了原始ACK之外的3个重复ACK，总共4个具有相同确认号的ACK）。</li>
<li><strong>为什么是3个</strong><ul>
<li>收到<strong>1或2个重复ACK可能是由于网络中的轻微乱序</strong>造成的，不一定代表丢包。</li>
<li>收到<strong>3个重复ACK则强烈暗示<code>Seq=200</code>很可能丢失</strong>，因为后面的3个段都已经到达。</li>
</ul>
</li>
</ul>
<h4 id="执行动作"><a href="#执行动作" class="headerlink" title="执行动作"></a>执行动作</h4><ul>
<li>一旦触发快速重传，发送方就 <strong>不再等待</strong> 该数据段（这里是<code>Seq=200</code>）的重传计时器超时，而是 <strong>立即重传</strong> 那个被认为丢失的数据段（Seq&#x3D;200）。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>相比超时重传，快速重传能够 <strong>显著更快地</strong> 发现并修复丢包，尤其是在高带宽、高延迟的网络中对吞吐量的提升效果明显。它使得TCP能够在不中断数据流的情况下（不需要等待超时）恢复丢失。</li>
</ul>
<h4 id="与快速恢复-Fast-Recovery"><a href="#与快速恢复-Fast-Recovery" class="headerlink" title="与快速恢复 (Fast Recovery)"></a>与快速恢复 (Fast Recovery)</h4><ul>
<li>快速重传通常与 <strong>快速恢复</strong> 算法结合使用。在快速重传一个数据段后，发送方不会像超时重传那样将拥塞窗口降得很低（例如降到1），而是采用一种更温和的方式调整拥塞窗口，试图在修复丢包的同时维持较高的数据传输速率。（<code>快速恢复算法</code>请查看<code>拥塞控制</code>章节）</li>
</ul>
<h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><p>滑动窗口机制是TCP在数据传输过程中，用于控制发送速率与接收能力匹配的一种流量管理方式。它通过动态调整“窗口”范围，实现高效、可靠的字节流传输。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>我们分为发送方（Sender）和接收方（Receiver）两个方面介绍</p>
<h4 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h4><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog_images/1.png"
                      alt="Loading..." style="zoom:50%;" 
                >

<p>我们来分别介绍一下这四个部分：</p>
<ul>
<li><strong>已发送并已确认 (Sent and Acknowledged):、</strong> 这部分数据已经成功发送并收到了接收方的确认。窗口的左边界会向右移动，越过这些字节。</li>
<li><strong>已发送但未确认 (Sent but Not Yet Acknowledged):</strong> 这部分数据已经发送出去，但还没有收到接收方的确认。这些数据仍在发送窗口内，发送方需要保留这些数据的副本，以备重传。</li>
<li><strong>允许发送但尚未发送 (Allowed to Send but Not Yet Sent):</strong> 这是发送窗口中可以立即发送的新数据部分。</li>
<li><strong>不允许发送 (Not Allowed to Send):</strong> 这部分数据在发送窗口之外，暂时不能发送。</li>
</ul>
<p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p>
<blockquote>
<p>动画演示可参考《计算机网络：自顶向下方法（第七版）》所提供的动画演示，<a class="link"   target="_blank" rel="noopener" href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/content/interactiveanimations/selective-repeat-protocol/index.html" >配套动画资源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h5 id="动态变化分析"><a href="#动态变化分析" class="headerlink" title="动态变化分析"></a>动态变化分析</h5><p>滑动窗口（指的是&#x3D;&#x3D;已发送未确认&#x3D;&#x3D;+&#x3D;&#x3D;允许发送但尚未发送&#x3D;&#x3D;两个部分）是&#x3D;&#x3D;动态变化&#x3D;&#x3D;的，而不是一段固定大小的字节块，下面我们就来分析一下具体的动态变化过程：</p>
<blockquote>
<p>注意，这里的动态变化指的是其大小是受到<code>cwnd</code>和<code>rwnd</code>的限制的，具体来说 <code>滑动窗口大小 = min(cwnd, rwnd)</code> ，而在边界移动时，窗口时整体变化的，而不是只移动某一边界</p>
</blockquote>
<ul>
<li><strong>发送数据：</strong> 当发送方发送数据时，窗口内<code>允许发送但尚未发送</code>的部分字节被发送出去，它们的状态变为&#x3D;&#x3D;已发送但未确认&#x3D;&#x3D;。</li>
<li><strong>接收确认 (ACK)：</strong> 当发送方收到接收方的<code>确认号 (Acknowledgment Number)</code> 时，表示&#x3D;&#x3D;该确认号之前的所有字节（不包括确认号本身）都已被接收方成功接收&#x3D;&#x3D;。发送窗口的<strong>左边界</strong>就可以向右滑动到这个确认号的位置。</li>
<li><strong>窗口滑动：</strong> 左边界向右移动，意味着窗口整体向右滑动。如果此时接收方通告的接收窗口大小没有变化，那么右边界也会相应向右移动，允许发送更多新的数据。</li>
<li><strong>超时重传：</strong> 如果发送方在一定时间内没有收到对某个已发送报文段的确认，就会认为该报文段丢失，并进行重传。</li>
</ul>
<h4 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h4><h5 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog_images/2.png"
                      alt="Loading..." style="zoom:50%;" 
                >

<p>可以看到，不同于发送端，接收端的TCP滑动窗口只有三个部分：</p>
<p>我们来分别介绍一下接收端的这三个部分：</p>
<ul>
<li><p><strong>已接收并确认 (Received and Acknowledged):</strong> 这部分数据已经成功接收并且已向发送方发送了确认报文。这些数据已经交付给应用层或正在等待按序交付。当确认后，窗口的左边界会向右移动，表示接收方已经处理了这些字节。</p>
</li>
<li><p><strong>允许接收 (Allowed to Receive):</strong> 这是接收窗口中可以接收的新数据部分。这些序列号的数据还未到达，但接收方已为它们分配了缓冲区空间，并已告知发送方可以发送这些序列号的数据。当这部分数据到达时，会被存入接收缓冲区并发送确认。</p>
</li>
<li><p><strong>不允许接收 (Not Allowed to Receive):</strong> 这部分数据的序列号超出了接收窗口的右边界（<code>RCV.NXT+RCV.WND</code>），接收方当前无法接收这些数据。如果接收方收到这个范围内的数据段，通常会丢弃它们或者将它们暂存在特殊缓冲区中（取决于具体实现），但不会确认这些数据。只有当接收窗口向右滑动，这些序列号进入”允许接收”范围后，才能被正常处理。</p>
</li>
</ul>
<h5 id="动态变化分析-1"><a href="#动态变化分析-1" class="headerlink" title="动态变化分析"></a>动态变化分析</h5><p>接收窗口（指的是&#x3D;&#x3D;允许接收&#x3D;&#x3D;部分）也是&#x3D;&#x3D;动态变化&#x3D;&#x3D;的，下面我们分析接收端滑动窗口的动态变化过程：</p>
<ul>
<li><p><strong>接收数据</strong>： 当接收方收到序列号落在”允许接收”范围内的数据段时，会将其存入接收缓冲区。如果收到的是当前期望的序列号（RCV.NXT），接收方会向发送方发送一个ACK，确认号为已接收数据的最后一个字节序号加1。</p>
</li>
<li><p><strong>处理有序数据</strong>： 当接收到期望序列号的数据后，接收窗口的左边界（RCV.NXT）会向右移动。如果已经接收了连续的数据，左边界会一直向右移动到第一个尚未接收的字节位置。接收方会同时发送新的ACK，其确认号为新的RCV.NXT值。</p>
</li>
<li><p><strong>处理乱序数据</strong>： 如果接收到的数据段序列号大于当前期望的序列号（乱序到达），接收方通常会：</p>
<ul>
<li><p>缓存这些乱序数据（存储在”允许接收”范围内）</p>
</li>
<li><p><strong>立即发送一个重复ACK</strong>，确认号仍为当前期望的序列号（RCV.NXT）</p>
<blockquote>
<p>这里发送的ACK报文会参与TCP的另一个机制，即<strong>快速重传机制</strong>，具体见<a href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0">快速重传</a></p>
</blockquote>
</li>
<li><p>等待缺失数据段到达后，再按序向应用层交付这些数据</p>
</li>
</ul>
</li>
<li><p><strong>窗口大小更新</strong>： 接收窗口大小会随着应用层处理数据的速度而变化：</p>
<ul>
<li>应用层从TCP接收缓冲区读取数据后，可用缓冲空间增加</li>
<li>接收窗口右边界相应向右移动，扩大”允许接收”范围</li>
<li>接收方通过ACK报文中的Window字段通告发送方新的窗口大小</li>
</ul>
</li>
<li><p><strong>零窗口通告</strong>： 如果应用层处理数据太慢，接收缓冲区可能会填满。此时，接收方会向发送方发送窗口大小为0的通告（零窗口），要求发送方暂停发送数据。当应用层继续读取数据并释放缓冲区空间后，接收方会发送窗口更新报文，通知发送方恢复数据传输。</p>
</li>
</ul>
<p>接收窗口的动态变化确保了TCP能够在有限的缓冲区资源下可靠地接收并有序地交付数据，同时通过窗口大小的通告实现了从接收方到发送方的流量控制。</p>
<h5 id="二者的关联"><a href="#二者的关联" class="headerlink" title="二者的关联"></a>二者的关联</h5><ol>
<li><p>再谈滑动窗口</p>
<p>​    滑动窗口其实可以理解成是一种标识，标记当前正在处理的数据范围，同时会根据网络的阻塞情况进行动态调整（具体的调整过程一般都是接收端通过TCP报头的Windows字段控制），具体来说，一个滑动窗口的大小有两个量决定，一个是接收端可接收的数据量（rwnd），一个是发送端的可接收数据量（cwnd）</p>
</li>
<li><p>二者的关系</p>
<p>​    前面也提到过，滑动窗口的大小是由两者共同决定的（取二者中的较小值），具体来说</p>
<blockquote>
<ol>
<li>发送端会记录接收端TCP报头中的窗口大小信息（由接收端计算并填充），然后和自己的CWND（拥塞窗口）进行比较</li>
<li>而发送端CWND大小的维护，依赖于复杂的<a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制机制</a></li>
<li>滑动窗口的大小 &#x3D; min(RWND, CWND)</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="拥塞控制简述"><a href="#拥塞控制简述" class="headerlink" title="拥塞控制简述"></a>拥塞控制简述</h3><blockquote>
<p>这里做一个澄清：拥塞窗口是在滑动窗口的机制上结合拥塞控制算法实现的一种对窗口的控制机制，而不是像流量控制机制那样完全依赖于滑动窗口机制实现的，所以不可简单的将拥塞控制窗口认为是滑动窗口的产物（因为拥塞窗口的调整只依赖于Sender本端的拥塞控制算法，而不依赖于对端的信息进行调整）</p>
</blockquote>
<p>拥塞控制，实际上就是对发送端CWND窗口大小调整的一系列策略，包括<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>超时重传</strong>、<strong>快速重传</strong>、<strong>快速恢复</strong>等机制，下面具体介绍：</p>
<h3 id="CWND-Congestion-Window-拥塞窗口"><a href="#CWND-Congestion-Window-拥塞窗口" class="headerlink" title="CWND (Congestion Window &#x2F; 拥塞窗口)"></a>CWND (Congestion Window &#x2F; 拥塞窗口)</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog_images/3.png"
                      alt="Loading..." style="zoom:50%;" 
                >

<p>首先是发送端的滑动窗口，指的是<code>SND.WND</code>这一端，而拥塞窗口指的是其中可用的部分，具体来说就是这里的<code>SND.WND - (SND.NXT - SND.WNA)</code>这一部分，拥塞窗口由Sender端独立维护和调整，接收端并不清楚发送端的拥塞窗口大小，而针对Sender端拥塞窗口的调整，也是整个滑动窗口机制的核心，因为它保证了发送端的数据发送速率不会太快造成网络传输阻塞等问题；</p>
<h3 id="慢启动（Slow-Start，初始阶段）"><a href="#慢启动（Slow-Start，初始阶段）" class="headerlink" title="慢启动（Slow Start，初始阶段）"></a>慢启动（Slow Start，初始阶段）</h3><p>在慢启动阶段，每收到一个ACK确认报文，CWND增加一个MSS，注意虽然叫<code>慢启动</code>，但是如果不加以限制，会造成指数爆炸，因为每次发送的数据段数量都是建立在<code>之前窗口大小 + 新增的窗口大小</code>的基础上的，所以这是一个典型的指数增长模型，但是如果不加以限制，指数增长的数据段会造成严重的网络阻塞</p>
<blockquote>
<p><strong>MSS和MTU</strong></p>
<p><strong>MTU（Maximum Transmission Unit，最大传输单元）</strong></p>
<p>MTU 是指一种通信协议的某一层上面所能通过的最大数据包大小，通常与网络接口的物理特性和网络层协议有关，例如，在以太网中，MTU 一般是 1500 字节。所以一般<code>网络层 --&gt; 数据链路层</code>的每个数据包大小都<code>小于1500字节</code>。</p>
<p>&#x2F;&#x2F; TODO</p>
<p>对于一段超过1500字节的数据，传输时就会涉及到分片的问题，具体可见<a href="TODO">网络中的常见数据分片详解</a></p>
<p><strong>MSS (Maximum Segment Size，最大分段大小)</strong></p>
<p>MSS是<code>TCP协议</code>中的部分，它表示TCP数据包<code>每次能够传输的最大数据量</code>。一般而言，MSS都小于MTU，因为TCP传输时会带上报头信息（TCP-20字节，IP-20字节），其主要作用是为了防止<code>网络层（即IP）分片问题</code>，具体解释如下：</p>
<p><em><strong>MSS协商</strong></em></p>
<ol>
<li>首先在TCP三次握手时，双方会协商MSS的大小（TCP报头中的选项字段，具体来说是 <strong>“Maximum Segment Size” (MSS) 选项</strong>）<ol>
<li>客户端 (发起连接方)在发送第一个 SYN 包时，会在 TCP 头部选项中包含它计算出的 MSS_proposed 值<br>（<code>MSS_proposed = Local_Interface_MTU - IP_Header_Size - TCP_Header_Size</code>）</li>
<li>服务端在接收到客户端的SYN请求后，会读取客户端通告的MSS值，同时服务端也会根据自己的<code>MTU</code>计算出自身的<code>MSS_proposed</code>，在向客户端回复<code>SYN-ACK</code>时也会将自身的<code>MSS_proposed</code>加入到<code>TCP报头</code>中</li>
</ol>
</li>
<li>在完成连接建立后，双方会根据对端的MSS值，选取其中较小的值作为整个连接过程中的MSS</li>
</ol>
<p><em><strong>分片问题</strong></em></p>
<p>所谓的防止IP分片，其实就是在IP的上层<strong>TCP对数据做了预先处理</strong>，对于超过MSS的数据，进行分段操作（<code>TCP分段</code>），这样它们在传递到网络层后，就不会因为超过数据传输限制而进行IP分片了。</p>
</blockquote>
<h4 id="慢启动阈值（ssthresh-Slow-Start-Threshold）"><a href="#慢启动阈值（ssthresh-Slow-Start-Threshold）" class="headerlink" title="慢启动阈值（ssthresh - Slow Start Threshold）"></a>慢启动阈值（ssthresh - Slow Start Threshold）</h4><p>慢启动阈值就是为了解决上面慢启动的指数爆炸问题的，用于<strong>决定 TCP 何时从“慢启动 (Slow Start)”阶段切换到“拥塞避免 (Congestion Avoidance)”阶段</strong>，所以一般都是和拥塞避免算法绑定使用的，具体的调整逻辑见下文；</p>
<h3 id="拥塞避免（Congestion-Avoidance）"><a href="#拥塞避免（Congestion-Avoidance）" class="headerlink" title="拥塞避免（Congestion Avoidance）"></a>拥塞避免（Congestion Avoidance）</h3><p>拥塞避免算法就是通过一系列的算法机制，对CWND的增长进行控制的一种机制，为了实现维持高吞吐量的同时避免网络阻塞的目的</p>
<blockquote>
<p>注意这里的避免并不意味着完全消除阻塞，而是通过控制发送速率来推迟拥塞的发生或减轻阻塞带来的影响</p>
</blockquote>
<p>一般而言，有两种方式进行拥塞避免阶段：</p>
<ol>
<li><strong>慢启动切换</strong>：当拥塞窗口大小达到<code>慢启动阈值</code>时，就会<strong>切换到拥塞避免阶段</strong>，此时CWND会执行<code>线性增长</code></li>
<li><strong>快速恢复切换</strong>（只会出现在某些实现中）：在处理完由快速重传触发的丢包后，经过快速恢复阶段，TCP <strong>通常会进入拥塞避免阶段</strong>，而不是重新回到慢启动（因为<strong>快速重传被认为是轻微拥塞的信号</strong>）</li>
</ol>
<p><em><strong>拥塞避免阶段 CWND 的调整机制</strong></em></p>
<p>在拥塞避免阶段，每经过一个大约一个RTT，CWND增加一个MSS，具体来说，对于每个成功接收到的<strong>新的 ACK</strong> (确认了之前未确认的数据，而不是重复 ACK)，CWND 的增加量为：<code>CWND = CWND + MSS * (MSS / CWND)</code><br>可以这样理解，当发送方<strong>成功发送并收到一个完整窗口（大小为 CWND）的数据的确认</strong>后，它就将<strong>窗口大小增加一个 MSS</strong>。</p>
<p><em><strong>拥塞避免阶段的退出条件以及慢启动阈值的更新策略</strong></em><br>分为两种情况：</p>
<ol>
<li><p>发生<strong>超时重传</strong>（<strong>RTO - Retransmission Timeout</strong>），这通常被认为是<strong>严重拥塞</strong>的信号</p>
<ol>
<li>将 ssthresh 更新为 <code>max(FlightSize / 2, 2 * MSS)</code>（FlightSize 是指超时发生时已发送但未确认的数据量）</li>
<li>将 CWND 重置为一个很小的值，通常是 1 MSS (或者初始窗口 IW)。</li>
<li><strong>重新进入慢启动阶段</strong></li>
</ol>
</li>
<li><p>发生<strong>快速重传（收到3个或更多的重复ACK）</strong>，这通常被认为是<strong>轻微或局部拥塞</strong>的信号（此时网络依然有能力传输一些数据）</p>
<ol>
<li>将 ssthresh 更新为 <code>max(FlightSize / 2, 2 * MSS)</code></li>
<li>CWND 减半：CWND &#x3D; ssthresh (或者 CWND &#x3D; CWND &#x2F; 2，然后根据具体算法可能还会加上一些值代表重复ACK所代表的数据)。这被称为<strong>乘性减少 (Multiplicative Decrease)</strong></li>
<li>执行快速重传，重传丢失的那个数据段</li>
<li><strong>进入快速恢复 (Fast Recovery) 阶段</strong>。在快速恢复成功后，通常会直接进入<strong>拥塞避免阶段</strong>，而不是慢启动。</li>
</ol>
</li>
</ol>
<blockquote>
<h4 id="乘性减小-和-加性增大"><a href="#乘性减小-和-加性增大" class="headerlink" title="&#x3D;&#x3D;乘性减小&#x3D;&#x3D;和&#x3D;&#x3D;加性增大&#x3D;&#x3D;"></a>&#x3D;&#x3D;乘性减小&#x3D;&#x3D;和&#x3D;&#x3D;加性增大&#x3D;&#x3D;</h4><p>二者构成了著名的**AIMD（Additive Increase, Multiplicative Decrease）**拥塞控制策略的两个核心组成部分，是许多经典 TCP 拥塞控制算法（如 <code>TCP Reno</code>）的基础。</p>
<p><em><strong>加性增大（Additive Increase, AI）</strong></em><br>当 TCP 连接处于<strong>拥塞避免 (Congestion Avoidance)</strong> 阶段，并且没有检测到网络拥塞（即没有丢包）时，发送方的拥塞窗口 (CWND) <strong>线性地、缓慢地增加</strong>（和上面的一致，不做赘述）</p>
<p><em><strong>乘性减小（Multiplicative Decrease, MD）</strong></em><br>当 TCP 连接检测到<strong>网络拥塞</strong>时，通常是通过<strong>快速重传</strong>机制（收到3个或更多重复ACK）判断发生的，发送方的拥塞窗口 (CWND) <strong>显著地、按比例地减少</strong></p>
</blockquote>
<h3 id="超时重传（Timeout-Retransmission）"><a href="#超时重传（Timeout-Retransmission）" class="headerlink" title="超时重传（Timeout Retransmission）"></a>超时重传（Timeout Retransmission）</h3><p>具体的介绍见上文——<a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">重传机制-超时重传</a></p>
<p>这里主要介绍超时重传机制在拥塞控制算法中的应用：</p>
<blockquote>
<p>超时重传在拥塞控制中主要是作为标识网络阻塞的信号作用的，一旦发生超时重传，说明现在网络处于<code>严重阻塞阶段</code>，拥塞控制算法会调整CWND窗口大小以及慢启动阈值，具体见上文[拥塞避免](#拥塞避免（Congestion Avoidance）)</p>
</blockquote>
<h3 id="快速重传与快速恢复（Fast-Retransmit-and-Fast-Recovery）"><a href="#快速重传与快速恢复（Fast-Retransmit-and-Fast-Recovery）" class="headerlink" title="快速重传与快速恢复（Fast Retransmit and Fast Recovery）"></a>快速重传与快速恢复（Fast Retransmit and Fast Recovery）</h3><p>快速重传同样见上文——<a href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0">重传机制-快速重传</a>，而对于其在拥塞避免算法的应用，依然在[上文](#拥塞避免（Congestion Avoidance）)中有所涉及，这里补充一点</p>
<blockquote>
<p>快速重传是超时重传的一种优化方式，具体体现在：</p>
<ol>
<li><p>更早的检测和响应丢包</p>
<ul>
<li>对于超时重传算法，只有重传计时器超时，才会触发相应的重传行为</li>
<li>而对于快速重传，只需要连续接收到三个相同序号的ACK报文，就会触发对应的重传行为，而无需等待重传计时器超时</li>
</ul>
<p>这样的机制，在数据量较大时，可以极大的减少普通的超时重传算法带来的时间等待成本，更早的检测并响应丢包事件</p>
</li>
<li><p>减少不必要的等待时间，提高网络吞吐量</p>
</li>
<li><p>对网络拥塞的判断更精细（与快速恢复结合时）</p>
<ul>
<li>超时重传发生时，发送方通常认为网络可能发生了比较严重的拥塞，因此会大幅度降低拥塞窗口（例如，降到1个MSS）。</li>
<li>快速重传（通常与快速恢复 Fast Recovery 配合使用）认为，既然还能收到冗余ACK，说明网络连接并未完全中断，只是发生了个别数据包的丢失。因此，在执行快速重传后，拥塞控制算法（如TCP Reno中的快速恢复）通常不会像超时重传那样严厉地减少拥塞窗口，而是将其减半（或设置为ssthresh），并尝试继续发送新的数据（如果窗口允许），从而更快地恢复传输速率。</li>
</ul>
</li>
</ol>
</blockquote>
<p>这里只介绍**快速恢复（Fast Recovery）**机制</p>
<blockquote>
<h4 id="快速恢复（以经典的-TCP-Reno-为例）"><a href="#快速恢复（以经典的-TCP-Reno-为例）" class="headerlink" title="快速恢复（以经典的 TCP Reno 为例）"></a>快速恢复（以经典的 TCP Reno 为例）</h4><p>一般发生在快速重传发生后，主要目的是为了避免不必要的慢启动，因为快速重传意味着网络只是轻微阻塞，没有必要从慢启动阶段（过于保守和低效）慢慢增长窗口大小</p>
<p><em><strong>具体步骤</strong></em></p>
<ol>
<li><p><strong>调整拥塞控制参数 (进入快速恢复前或开始时)</strong></p>
<ul>
<li><p>首先是慢启动阈值 <code>ssthreth = max(FlightSize / 2, 2 * MSS)</code>，<code>FlightSize</code>是指在收到第 3 个重复 ACK 时，网络中已发送但未确认的数据量</p>
</li>
<li><p>第二步是设置拥塞窗口（CWND），<code>CWND = ssthreth + 3 * MSS</code>，<code>3 * MSS</code>是<code>TCP Reno</code>的特殊做法，为了<code>补偿</code>那 3 个已经离开网络的重复 ACK 所代表的数据包</p>
</li>
</ul>
</li>
<li><p><strong>重传丢失的数据段</strong></p>
<p>在接收到 3 个连续的ACK报文后，立即重传被认为丢失的那个数据段</p>
</li>
<li><p><strong>处理后续的重复 ACK (在快速恢复阶段)</strong></p>
<p>每当收到一个重复ACK报文，<code>CWND = CWND + 1 * MSS</code>，这个新的重复 ACK 进一步确认了又有一个数据包离开了网络（被接收方处理）。因此，发送方可以认为网络中又空出了一个 MSS 的空间，可以尝试发送一个新的数据段。</p>
</li>
<li><p><strong>处理新的、非重复的 ACK (结束快速恢复)</strong></p>
<p>如果收到一个新的ACK报文，该ACK报文确认了之前重传的那个丢失的数据段以及它之后的所有数据时（即它确认了所有到某个更高序列号的数据），此时恢复阶段完成，为了避免过高的发送速率，需要对窗口大小进行再次限制，<code>CWND = ssthreth</code>，设置完成后，正式退出恢复阶段</p>
<p>此后，进入拥塞避免阶段，<code>CWND</code>执行线性增长；</p>
</li>
</ol>
</blockquote>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="流量控制简述"><a href="#流量控制简述" class="headerlink" title="流量控制简述"></a>流量控制简述</h3><p>流量控制，和拥塞控制类似，是控制<code>RWND</code>（即接收窗口）的一系列机制，<strong>防止发送方发送数据的速度过快，以至于接收方来不及处理，导致接收方的缓冲区溢出而丢弃数据</strong>。</p>
<h3 id="RWND（Receive-Window-接收窗口）"><a href="#RWND（Receive-Window-接收窗口）" class="headerlink" title="RWND（Receive Window &#x2F; 接收窗口）"></a>RWND（Receive Window &#x2F; 接收窗口）</h3><p>&#x2F;&#x2F; TODO 图片</p>
<p>RWND 是 TCP 流量控制机制的核心组成部分。简单来说，它代表了<strong>接收方当前愿意并且能够接收的数据量（以字节为单位）</strong>。</p>
<h3 id="零窗口-Zero-Window-与零窗口探测-Zero-Window-Probe"><a href="#零窗口-Zero-Window-与零窗口探测-Zero-Window-Probe" class="headerlink" title="零窗口 (Zero Window) 与零窗口探测 (Zero Window Probe)"></a>零窗口 (Zero Window) 与零窗口探测 (Zero Window Probe)</h3><h4 id="零窗口"><a href="#零窗口" class="headerlink" title="零窗口"></a>零窗口</h4><p>当接收方的 TCP 接收缓冲区完全满了，无法再接收更多数据时，它会通告一个<code>大小为 0 的 RWND</code>（即<code>零窗口</code>），发送端接收到零窗口通告后，必须<strong>立刻停止发送任何数据</strong></p>
<p>不过这种机制有一个潜在的隐患——<strong>死锁问题</strong>：如果接收端后续清空了缓冲区，并发送了一个带有新的非零 RWND 的 ACK（窗口更新报文），但这个<strong>窗口更新报文在网络中丢失</strong>了，那么发送方将永远不知道接收窗口已经打开，而接收方则在等待数据，<strong>导致连接死锁</strong>。</p>
<p>为了解决这个问题，引入了<strong>零窗口探测机制</strong>；</p>
<h4 id="零窗口探测"><a href="#零窗口探测" class="headerlink" title="零窗口探测"></a>零窗口探测</h4><p>​	 为了解决这个潜在的死锁问题，发送方在收到零窗口通告后会启动一个<strong>持续计时器 (Persist Timer)</strong>，当持续计时器超时后，发送方会发送一个小的<strong>探测报文</strong>（通常只包含 1 字节的数据，<strong>即使窗口是0，接收方也必须能处理这种探测</strong>），接收方收到探测报文后，<strong>必须回应一个 ACK</strong>，并在其中包含其当前的 RWND 值。</p>
<p>​	这样，即使之前的窗口更新报文丢失，发送方也能通过周期性的探测最终了解到接收窗口何时重新打开。探测的间隔通常会采用指数退避的方式增加。</p>
<blockquote>
<p>可以类比 TCP 的<code>心跳检测机制</code>，都是用于探测对端状态信息的，只不过一个是探测可接收窗口大小，一个是探测连接是否存在的</p>
</blockquote>
<h3 id="窗口缩放选项-Window-Scale-Option-RFC-7323-obsoletes-RFC-1323"><a href="#窗口缩放选项-Window-Scale-Option-RFC-7323-obsoletes-RFC-1323" class="headerlink" title="窗口缩放选项 (Window Scale Option - RFC 7323, obsoletes RFC 1323)"></a>窗口缩放选项 (Window Scale Option - RFC 7323, obsoletes RFC 1323)</h3><h4 id="为什么存在窗口缩放选项"><a href="#为什么存在窗口缩放选项" class="headerlink" title="为什么存在窗口缩放选项"></a>为什么存在窗口缩放选项</h4><p>TCP 头部中的<code>窗口大小</code>字段只有 16 位，最大能表示<code>65535 字节 (2^16 - 1)</code>。在高速、高延迟的网络（即“长肥管道” LFN, Long Fat Network）中，这个<strong>窗口大小不足以充分利用带宽</strong>（因为带宽延迟积 BDP 可能远大于 64KB）。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>窗口缩放选项是在<code>TCP建立连接</code>过程中通过<code>SYN</code>和<code>SYN-ACK</code>进行协商的，它定义了一个<strong>移位计数器(shift count)</strong>，取值范围 0-14，实际的接收窗口大小就由该移位计数器决定：</p>
<p><code>实际的接收窗口大小 = TCP 头部中的窗口值 * 2^(移位计数)</code></p>
<p>这种方式使得 TCP 能够通告更大的接收窗口，从而在 LFN 环境下也能实现高吞吐量，确保流量控制不会成为瓶颈。这本身不是一种新的“控制”机制，而是对核心RWND机制的增强，使其能适应更广泛的网络条件。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><h3 id="校验和简述"><a href="#校验和简述" class="headerlink" title="校验和简述"></a>校验和简述</h3><p>它是一种差错检测机制，用于<strong>检测其头部和数据在传输过程中是否发生了比特错误（即数据损坏）</strong>，尽管校验和机制相对简单，但是却可以有效的检验数据的完整性和正确性；</p>
<p><em><strong>为什么需要校验和机制</strong></em></p>
<p>网络传输过程中，由于各种干扰（如电磁干扰、硬件故障等），数据包中的比特位可能会发生翻转（0 变 1 或 1 变 0）。校验和的目的是检测出这些错误，从而保证TCP连接的双方的数据一致性；</p>
<h3 id="校验和的计算"><a href="#校验和的计算" class="headerlink" title="校验和的计算"></a>校验和的计算</h3><h4 id="计算范围"><a href="#计算范围" class="headerlink" title="计算范围"></a>计算范围</h4><ol>
<li><p><strong>TCP 伪头部 (Pseudo-header)</strong></p>
<ol>
<li><p>什么是伪头部</p>
<p>这是一个<strong>虚拟的头部字段</strong>，仅用于校验和的计算，并<strong>不实际在网络上传输</strong>，一共包含以下字段，每个字段都有其对应的功能</p>
<ul>
<li>源 IP 地址 (Source IP Address) - 4 字节：确保 TCP 段确实来自预期的发送方</li>
<li>目标 IP 地址 (Destination IP Address) - 4 字节：确保 TCP 段确实是发往预期的接收方。这是伪头部中<strong>最重要</strong>的字段之一，主要用于防止错误投递</li>
<li>协议字段 (Protocol) - 1 字节 (对于 TCP，值为 6)：确保 TCP 段确实应该由 TCP 协议栈来处理，而不是其他传输层协议</li>
<li>TCP 长度 (TCP Length) - 2 字节 (表示 TCP 头部长度 + TCP 数据长度)：确保 TCP 协议栈接收到的 TCP 段的长度（包括 TCP 头部和 TCP 数据）与发送方发送时声明的长度一致</li>
<li>一个全零的字节 (Zero) - 1 字节 (用于凑齐偶数长度)：这个字段在 IPv4 的伪头部中主要用于<strong>填充</strong>，使得伪头部的总长度为 12 字节，这是一个偶数，方便进行 16 位字的校验和计算。同时，它也确保了伪头部结构的一致性。</li>
</ul>
</li>
<li><p>为什么要加入伪头部</p>
<p>​    考虑以下场景：一个 TCP 数据段在网络传输过程中，其 IP 头部可能因为某种原因（例如路由器故障、配置错误）被损坏或修改，导致这个 TCP 段被错误地路由到了一个<strong>非预期的目标主机</strong>。但是如果 TCP 校验和只计算 TCP 头部和数据部分，那么即使这个 TCP 段被送到了错误的主机，只要 TCP 头部和数据本身没有损坏，校验和仍然可能是正确的。</p>
<p>​    然而错误的主机可能会尝试处理这个不属于它的 TCP 段，这可能导致不可预料的行为或安全问题。</p>
<p>​    <strong>通过在伪头部中包含目标 IP 地址</strong>，校验和的计算就将目标地址也纳入了保护范围。如果 IP 头部中的目标地址与伪头部中的目标地址不符（这意味着数据段被错误路由），即使 TCP 头部和数据本身完好，接收端的 TCP 校验和计算（使用其本地 IP 地址构造伪头部）也会失败。这将导致该 TCP 段被丢弃，从而防止了对错误投递数据段的处理。</p>
<p>具体的字段及其作用可参考上文。</p>
</li>
</ol>
</li>
<li><p><strong>TCP 头部 (TCP Header)</strong></p>
<p>TCP 协议的完整头部，包括源端口、目标端口、序列号、确认号、标志位、窗口大小、选项等。</p>
<p>&#x3D;&#x3D;注意，在计算校验和之前，TCP 头部中的<strong>校验和字段本身会被置为 0</strong>&#x3D;&#x3D;</p>
</li>
<li><p><strong>TCP 数据 (TCP Data &#x2F; Payload)</strong></p>
<p>TCP 段中承载的应用层数据，如果数据部分的长度为奇数个字节，会在末尾<strong>逻辑上</strong>添加一个全零的字节 (padding byte) 来凑成偶数个字节进行计算，但这个填充字节并不会实际发送。（可参考<code>TCP 伪头部的末尾全0字节</code>）</p>
</li>
</ol>
<h4 id="校验和的计算方法"><a href="#校验和的计算方法" class="headerlink" title="校验和的计算方法"></a>校验和的计算方法</h4><p>TCP 校验和采用的是一种称为 <strong>“16位反码算术和的反码” (One’s Complement of the One’s Complement Sum of 16-bit Words)</strong> 的算法。步骤如下：</p>
<ol>
<li><p><strong>数据拼接</strong></p>
<p>​    首先将伪头部、TCP头部（校验和字段置零）和TCP数据（如果是奇数字节，需要在末尾填充一个零字节）连接起来，形成一个连续的字节序列，将其看作是一系列16位的字（word）</p>
</li>
<li><p><strong>计算16位反码和</strong></p>
<p>​    将所有的这些16位的字进行<strong>反码加法 (One’s Complement Addition)</strong></p>
<blockquote>
<p>反码加法的规则：</p>
<ol>
<li>二进制相加</li>
<li>如果最高位产生进位，则将这个仅为加回到结果的最低为（<code>回卷</code>或<code>循环进位</code>）</li>
<li>重复1，2，直到所有的16位的字都加完，得到一个16位的和</li>
</ol>
</blockquote>
</li>
<li><p><strong>取反码</strong></p>
<p> ​    将上一步得到的16位和进行<strong>按位取反 (One’s Complement)</strong>，最后得到的结果就是TCP的校验和</p>
</li>
<li><p><strong>填充校验和字段</strong></p>
</li>
</ol>
<h3 id="校验和的验证过程（接收端）"><a href="#校验和的验证过程（接收端）" class="headerlink" title="校验和的验证过程（接收端）"></a>校验和的验证过程（接收端）</h3><ol>
<li><p><strong>数据构造</strong></p>
<p>​    和校验和生成机制一样，验证过程也需要构造出伪头部字段，将伪头部、收到的TCP头部（此时校验和字段包含发送方计算的值）和TCP数据连接起来，同样将这个序列看作一系列的16位的字</p>
</li>
<li><p><strong>计算16位的反码和</strong></p>
<p>​    对所有这些16位的字（包括<strong>TCP头部中收到的校验和字段的值</strong>）进行反码加法</p>
</li>
<li><p><strong>验证结果</strong></p>
<p>​    先说结果，如果数据在传输过程中没有发生错误，那么接收端计算出的 16 位反码和<strong>应该全为 1</strong> (即二进制 1111111111111111，十六进制 0xFFFF)。</p>
<blockquote>
<h4 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h4><p>我们这里将接收端接收到的TCP报文分为这几个部分：</p>
<ul>
<li>伪头部（由接收端自己构造的）</li>
<li>TCP除校验和字段之外的部分</li>
<li>TCP 数据（TCP Data）</li>
<li>发送端计算并填充的校验和字段（Checksum_S）</li>
</ul>
<p>对于接收端的反码计算，我们可以把前三个部分（伪头部 + TCP头部(除校验和字段) + TCP数据）计算出来的反码和，即<code>Sum_S</code>视为一个整体，那么接收端计算的<code>Sum_R</code>可以近似的看作是</p>
<p><code>Sum_R = 反码加法(Sum_S, Checksum_S)</code></p>
<p>而又因为<code>Checksum_S = NOT(Sum_S)</code>，代入上式，可得</p>
<p><code>Sum_R = 反码加法(Sum_S, NOT(Sum_S))</code>，根据反码计算性质，可得<code>如果数据传输没有问题的话，结果总是全1的</code>，即结果为<code>OxFFFF</code></p>
</blockquote>
</li>
<li><p><strong>处理错误</strong></p>
<p>​    如果校验和验证失败（结果不是全1），接收方会<strong>静默丢弃</strong>该 TCP 段。它<strong>不会发送 NACK</strong> (Negative Acknowledgment)。<br>​    而发送方最终会因为没有收到对该数据段的 ACK（或者因为后续数据段的 ACK 表明该段丢失）而<strong>触发重传机制（超时重传或快速重传）</strong>。</p>
<p>​</p>
</li>
</ol>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="连接管理概述"><a href="#连接管理概述" class="headerlink" title="连接管理概述"></a>连接管理概述</h3><p>TCP (Transmission Control Protocol) 是一种<strong>面向连接的</strong>、<strong>可靠的</strong>、基于字节流的传输层通信协议。其“面向连接”的特性就体现在它的连接管理机制上。</p>
<p>TCP连接管理主要包括三个阶段，具体来说：</p>
<ul>
<li><strong>连接建立 (Connection Establishment) - 三次握手 (Three-Way Handshake)</strong></li>
<li><strong>数据传输 (Data Transfer)</strong></li>
<li><strong>连接终止 (Connection Termination) - 四次挥手 (Four-Way Handshake)</strong></li>
</ul>
<p>后文就会对这三个阶段的具体行为进行介绍。</p>
<h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p>连接建立阶段会经过三次握手，我们分为行为层和状态变化层这两个层面进行介绍：</p>
<h4 id="行为层"><a href="#行为层" class="headerlink" title="行为层"></a>行为层</h4><p>TCP连接的建立分为三步——即对应<strong>三次握手</strong></p>
<ol>
<li>首先<strong>客户端发起连接请求</strong>（注意，一定是客户端发起的连接请求），根据上面的<code>标志位</code>，可以查到当前标志位应该被设置为SYN，向服务端发起请求；</li>
<li>服务端接收到连接请求（注意，<strong>在此之前，服务端一直处于LINSTEN状态</strong>，这表示一种监听状态，一旦有连接请求，服务端会立即执行对应操作），先对请求进行确认，随后会向客户也发送一个连接请求（注意，这里为了节省报文发送的数量，采取了<strong>捎带应答</strong>（后面会谈到），将ACK和SYN并作一起发送给客户端；</li>
<li>客户端在接收到了对应的连接请求后，也<strong>向服务端发送ACK确认报文</strong>，至此，TCP建立连接的三次握手完成；</li>
</ol>
<h4 id="状态层"><a href="#状态层" class="headerlink" title="状态层"></a>状态层</h4><ol>
<li>首先<code>Client</code>发送<strong>SYN连接请求</strong>，进入<strong>SYN_SENT状态</strong>；</li>
<li><code>Server</code>接收到连接请求，向<code>Client</code>同样发送<strong>SYN连接请求</strong>，同时<strong>捎带ACK确认报文</strong>（称为<strong>捎带应答</strong>），从<strong>LISTEN</strong>状态转变为<strong>SYN_RCVD</strong>状态；</li>
<li><code>Client</code>接收到<code>Server</code>的确认报文后，从<strong>SYN_SENT</strong>状态转变为<strong>ESTABLISHED</strong>状态，说明<code>Client</code>的<strong>TCP连接已经建立完成</strong>，并向<code>Server</code>发送<strong>ACK确认报文</strong>；</li>
<li><code>Server</code>接收到<strong>ACK</strong>后，从<strong>SYN_RECD</strong>状态转变为<strong>ESTABLISHED</strong>状态；</li>
</ol>
<p>自此，TCP的<strong>三次握手完成</strong>，<strong>TCP连接正式建立</strong>；</p>
<p>&#x2F;&#x2F; TODO 图片</p>
<h3 id="连接断开阶段"><a href="#连接断开阶段" class="headerlink" title="连接断开阶段"></a>连接断开阶段</h3><p>因为TCP是<strong>全双工通信</strong>，所以<strong>断开连接必须要双端分别发起一次断开请求</strong>，只有一方断开连接并不是真正意义上的TCP连接断开行为，正因为如此，TCP断开请求需要4步</p>
<h4 id="行为层-1"><a href="#行为层-1" class="headerlink" title="行为层"></a>行为层</h4><ol>
<li><p>首先，一方（这里是客户端还是服务端没有严格要求）<strong>发起断开请求（对应标志位为FIN）</strong></p>
</li>
<li><p>当另一方接收到请求报文时，会<strong>向对端发送一个确认报文（ACK）</strong>；</p>
</li>
<li><p>这时，接收到报文的一方也会<strong>向其对端发送断开请求（同样是FIN</strong>）；</p>
</li>
<li><p>另一方<strong>接收报文并返回确认报文（ACK）</strong></p>
</li>
</ol>
<blockquote>
<h4 id="为什么这里不能像连接建立阶段那样，进行捎带应答呢？"><a href="#为什么这里不能像连接建立阶段那样，进行捎带应答呢？" class="headerlink" title="为什么这里不能像连接建立阶段那样，进行捎带应答呢？"></a>为什么这里不能像连接建立阶段那样，进行捎带应答呢？</h4><p>因为不同于建立连接时，双端都未进行通信，连接中没有任何残留数据（不考虑上一次TCP连接的残留），双方的目的就是为了尽快建立连接，所以采用了捎带应答机制；</p>
<p>而对于断开连接来说，一端发送断开请求，只是意味着此时请求断开的一端没有数据需要发送，但是它还可以继续接收数据，此时的连接中可能会存在由对端发送来的数据，而TCP作为可靠的传输协议，必须等待数据传输完后才可以发送断开请求，从而保证数据的安全、可靠传输，不会发生丢失等问题；</p>
</blockquote>
<p>至此，<strong>TCP四次挥手过程完成</strong>，<strong>TCP连接断开</strong></p>
<h4 id="状态层-1"><a href="#状态层-1" class="headerlink" title="状态层"></a>状态层</h4><ol>
<li><p><code>Client</code>发送<strong>FIN请求</strong>，请求断开连接，从<strong>ESTABLISHED</strong>状态转为<strong>FIN_WAIT1</strong>状态；</p>
</li>
<li><p><code>Server</code>接收到<strong>FIN请求</strong>，状态变为<strong>CLOSE_WAIT</strong>，随后向<code>Client</code>发送<strong>ACK确认报文</strong></p>
</li>
<li><p><code>Client</code>接收到<strong>ACK确认报文</strong>，从<strong>FIN_WAIT1</strong>状态变为<strong>FIN_WAIT2</strong>状态</p>
</li>
<li><p>随后由<code>Server</code>向<code>Client</code>发送<strong>FIN请求</strong>，状态转为<strong>LAST_ACK</strong></p>
</li>
<li><p><code>Client</code>接收到对应请求，注意此时<code>Client</code>端将保持当前状态，随后向<code>Server</code>发送<strong>ACK确认报文</strong>，进入<strong>TIME_WAIT</strong>状态</p>
</li>
<li><p><code>Server</code>在接收到<strong>ACK确认报文</strong>后，进入<strong>CLOSED</strong>状态，此时<code>Server</code>的<strong>TCP连接关闭</strong>，<strong>释放连接资源</strong></p>
</li>
<li><p>在发送<strong>ACK确认报文</strong>后，<code>Client</code>会进入<code>2MSL</code> 等待状态</p>
<p>（<strong>MSL: Maximum Segment Lifetime，报文最大生存时间</strong>）</p>
<blockquote>
<p>为什么需要经历<code>2MSL</code>的等待时间？</p>
<ul>
<li><p>确保发送的最后一个ACK能够到达服务器。如果这个ACK丢失，服务器会因为没收到ACK而重传FIN，客户端在 <code>TIME_WAIT</code> 状态下可以重新发送ACK。</p>
</li>
<li><p>防止“已失效的连接请求报文段”出现在本连接中。等待2MSL可以确保本次连接中产生的所有报文段都从网络中消失。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p>至此，双方都完成了TCP连接的关闭，正式断开</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> TCP协议是如何实现可靠性传输的</li>
        <li><strong>作者:</strong> The Redefine Team</li>
        <li><strong>创建于
                :</strong> 2024-12-17 13:14:00</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-05-15 12:09:55
            </li>
        
        <li>
            <strong>链接:</strong> https://redefine.ohevan.com/2024/12/17/详解TCP协议的可靠性传输实现/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/NetWork/">#NetWork</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/12/27/WebSocket/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">WebSocket协议详解</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/12/09/HTTP%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">HTTP各个版本对比</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://blogcomment-virid.vercel.app/',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">TCP协议是如何实现可靠性传输的</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="nav-text">TCP协议是如何实现可靠性传输的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7%E4%B8%8E%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94"><span class="nav-text">序列号与确认应答</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="nav-text">序列号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94"><span class="nav-text">确认应答</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-text">重传机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-text">快速重传</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="nav-text">滑动窗口机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%80%E8%BF%B0"><span class="nav-text">拥塞控制简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CWND-Congestion-Window-%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3"><span class="nav-text">CWND (Congestion Window &#x2F; 拥塞窗口)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8%EF%BC%88Slow-Start%EF%BC%8C%E5%88%9D%E5%A7%8B%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="nav-text">慢启动（Slow Start，初始阶段）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%EF%BC%88Congestion-Avoidance%EF%BC%89"><span class="nav-text">拥塞避免（Congestion Avoidance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%88Timeout-Retransmission%EF%BC%89"><span class="nav-text">超时重传（Timeout Retransmission）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%EF%BC%88Fast-Retransmit-and-Fast-Recovery%EF%BC%89"><span class="nav-text">快速重传与快速恢复（Fast Retransmit and Fast Recovery）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%AE%80%E8%BF%B0"><span class="nav-text">流量控制简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RWND%EF%BC%88Receive-Window-%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="nav-text">RWND（Receive Window &#x2F; 接收窗口）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E7%AA%97%E5%8F%A3-Zero-Window-%E4%B8%8E%E9%9B%B6%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B-Zero-Window-Probe"><span class="nav-text">零窗口 (Zero Window) 与零窗口探测 (Zero Window Probe)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%BC%A9%E6%94%BE%E9%80%89%E9%A1%B9-Window-Scale-Option-RFC-7323-obsoletes-RFC-1323"><span class="nav-text">窗口缩放选项 (Window Scale Option - RFC 7323, obsoletes RFC 1323)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-text">校验和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%AE%80%E8%BF%B0"><span class="nav-text">校验和简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">校验和的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E9%AA%8C%E8%AF%81%E8%BF%87%E7%A8%8B%EF%BC%88%E6%8E%A5%E6%94%B6%E7%AB%AF%EF%BC%89"><span class="nav-text">校验和的验证过程（接收端）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text">连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-text">连接管理概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E9%98%B6%E6%AE%B5"><span class="nav-text">连接建立阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E9%98%B6%E6%AE%B5"><span class="nav-text">连接断开阶段</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">The Redefine Team</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 13 篇文章
                    </span>
                    
                        <span>
                            共 54.9k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
            <div class="icp-info my-1"><a target="_blank" rel="nofollow" href="
                
                    https://beian.miit.gov.cn/
                
                ">皖ICP备2024065853号-1</a></div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>





    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>